{"version":3,"sources":["Components/GridItem.jsx","PathfindingAlgorithms/Utility.js","PathfindingAlgorithms/Graph.jsx","PathfindingAlgorithms/Node.jsx","PathfindingAlgorithms/PriorityQueue.jsx","PathfindingAlgorithms/Dijkstra.js","PathfindingAlgorithms/Astar.js","PathfindingAlgorithms/Maze.js","Components/PathfindingLayout.jsx","Components/Layout.jsx","App.js","reportWebVitals.js","index.js"],"names":["GridItem","props","cellWasHovered","e","preventDefault","buttons","gridWasClicked","document","selection","empty","window","getSelection","removeAllRanges","cellWasClicked","state","node","styleName","styleObj","showWeight","weight","nodeObj","this","itemNode","setState","prevProps","isConstructed","visited","styleColor","undefined","className","style","onClick","onMouseOver","React","Component","getIndex","parseInt","split","compareNodes","node1","node2","sleep","ms","Promise","resolve","setTimeout","Graph","graph","adjacencyList","start","goal","initAdjList","newNode","gridIndex","nodeType","removeEdge","x","y","length","Object","entries","generateNodeNeighbours","toString","nodeTuple","oldNeighbours","calcMovementCost","row","col","generateEdges","addEdge","Node","neighbours","push","idx","type","index","indexOf","splice","PriorityQueue","queue","nodeIdx","priorityValue","qElem","doesContain","i","isEmpty","shift","Dijkstra","Adj","console","log","prioQ","shortestPath","toBeVisited","dist","parent","Infinity","queue_item","minNode","dequeue","neighbour","calcHeurestic","x1","y1","x2","y2","dx","Math","abs","dy","min","Astar","openSet","gScore","visitedNodes","nodesInOrder","next","includes","newCost","Maze","AdjList","adj","init","nodes","keys","maxRow","maxCol","tmpRow","j","generateMaze","nodeStr","wallList","wall","floor","random","visitedCounter","wallNeighbours","PathfindingLayout","handleSpeedSlider","animationSpeed","target","value","handleCheckboxChange","showWeights","gridItem","isAnimating","cancelAnimation","drawMode","gridStartPos","oldX","oldY","oldStartNode","gridState","updateGridItem","gridEndPos","oldEndNode","gridRowCount","gridColCount","algorithm","curGrid","isVisualized","handleAlgorithmModeChange","bind","handleDrawModeChange","handleResetClick","handleSimulateClick","animate","AlgorithmTypes","freeze","initGrid","newId","oldGrid","oldNode","oldGridItem","cloneElement","newGraph","oldGraph","updateNode","dijkstra","astar","c","_styleObj","newGridItem","isAnimated","maze","newGrid","BFS","oldGridState","_styleName","tmpGraph","elem","tmpArr","width","innerWidth","height","innerHeight","colCount","rowCount","counter","pushElemsToGrid","grid","name","id","onChange","max","map","item","Layout","currentLayout","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.17e0c9e3.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Grid.scss'\r\n\r\n//Just an object thats state is controlled by the grid\r\n//Used for animation and visualization only\r\nclass GridItem extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            node: this.props.node,                  //Node object that's stored in this gridItem component. TODO:: Store all node objects in parent and then just pass their needed values as props to this component\r\n            styleName: this.props.styleName,        //Css style name what is changed with selecte drawing mode\r\n            styleObj: this.props.styleObj,          //Inline style object that's passed as a prop from parent, used to calculate the RGB color of the node from the weight value\r\n            showWeight: this.props.showWeight,      //This is a boolean for showing weights, has currently no use\r\n            weight: this.props.weight               //The actual weight value of the node after running desired algorithm\r\n        };\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        let nodeObj = this.props.itemNode\r\n        this.setState({node: nodeObj, styleName: this.props.styleName, styleObj: this.props.styleObj, showWeight: this.props.showWeight, weight: this.props.weight});\r\n    }\r\n\r\n    componentDidUpdate(prevProps)\r\n    {\r\n        if(this.props.showWeight !== prevProps.showWeight)\r\n            this.setState({showWeight: this.props.showWeight})\r\n        if(this.props.styleName !== prevProps.styleName)\r\n            this.setState({styleName: this.props.styleName})\r\n    }\r\n\r\n    //Handle cell hover over if mouse buttons are being pressed down, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasHovered = (e) => {\r\n        e.preventDefault();\r\n        var unFocus = function () {\r\n            if (document.selection) {\r\n              document.selection.empty()\r\n            } else {\r\n              window.getSelection().removeAllRanges()\r\n            }\r\n        } \r\n        //If the mouse buttons are being held down\r\n        if(e.buttons === 1 || e.buttons === 3)\r\n        {\r\n            \r\n            this.props.gridWasClicked(this);\r\n            unFocus();\r\n        }\r\n    }\r\n\r\n    //Handle cell click, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasClicked = (e) => {\r\n        e.preventDefault();\r\n        this.props.gridWasClicked(this);\r\n    }\r\n\r\n    render(){\r\n        //Variables that change depending on the passed props\r\n        let isConstructed = this.state.node ? true : false;\r\n        let styleName = this.props.visited ? this.props.styleName : this.state.styleName\r\n        let styleColor = this.props.visited ? this.props.styleObj : undefined\r\n        //let weightValue = this.props.showWeight ? this.state.weight : \"\"      //This can be used to display weights of the nodes\r\n        if(isConstructed)\r\n        {\r\n            return(\r\n                <div className={styleName} style={styleColor} onClick={this.cellWasClicked} onMouseOver={this.cellWasHovered}>    \r\n                </div> \r\n            ); \r\n        }\r\n        else{\r\n            return(<div/>)\r\n        }\r\n    }\r\n}\r\n\r\nexport default GridItem;","export function getIndex(node)\r\n{\r\n    //Since the grid index is stored a string in the node\r\n    //This quick hack function will always return the node's index value as integer\r\n    //check if nodeIdx is string or int array\r\n    if(typeof node != \"string\")\r\n        return node\r\n    let x = parseInt(node.split(',')[0])\r\n    let y = parseInt(node.split(',')[1])\r\n    return [x,y]\r\n}\r\n\r\nexport function compareNodes(node1, node2)\r\n{\r\n    if(node1[0] == node2[0] && node1[1] == node2[1])\r\n        return true\r\n    else\r\n        return false\r\n}\r\n\r\nexport function sleep(ms)\r\n{\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}","import {getIndex} from './Utility'\r\n\r\nexport class Graph{\r\n    \r\n    constructor(graph)\r\n    {\r\n        this.graph = graph;\r\n        this.adjacencyList = {}\r\n        this.start = undefined;\r\n        this.goal = undefined;\r\n        //this.adjacencyList is adjacency list (key value paired dict type object) of nodes\r\n        /** For example\r\n        graph = {\r\n                node1: {node2 : 10, node3 : 14},\r\n                node2: ...,\r\n                }\r\n         */\r\n        this.initAdjList();\r\n    }\r\n\r\n    //Function for updating nodes after the graph is initialized\r\n    //E.g a node in graph changes to an obstacle, we remove edges between this node and it's neighbours, and delete the node after\r\n    updateNode(newNode)\r\n    {\r\n        //First update the node\r\n        this.graph[newNode.gridIndex[1]][newNode.gridIndex[0]][1] = newNode\r\n        //Check if the newly changed node was obstacle, if it was\r\n        //Remove the edges from this node to anywhere else\r\n        //We could also check if the node used to be an obstacle, then we would have no operations to perform\r\n        if(newNode.nodeType === 3)\r\n        {\r\n            for(var node in this.adjacencyList[newNode.gridIndex])\r\n            {\r\n                //Remove edges node->neighbour and neighbour->node\r\n                this.removeEdge(newNode.gridIndex, node)\r\n            }\r\n            \r\n            //Check diagonials if they're obstacles, if they're, remove edges between the non-obstacle nodes from x & y axis\r\n            var [x,y] = newNode.gridIndex\r\n            //x max = this.graph.length, x === row\r\n            //Check if col and row is out of bounds aswell\r\n            //Top right\r\n            if(x+1 < this.graph[0].length && y-1 > 0 && this.graph[y-1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x+1, y])\r\n            }\r\n            //Bottom right\r\n            if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x+1,y], [x, y+1])\r\n            }\r\n            //Bottom left\r\n            if(x-1 > 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x-1,y], [x, y+1])\r\n            }\r\n            //Top left\r\n            if(x-1 > 0 && y-1 > 0 && this.graph[y-1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x-1, y])\r\n            }\r\n\r\n\r\n            //Remove the node from graph\r\n            //delete this.adjacencyList[newNode.gridIndex]\r\n            \r\n            //TODO:: WE COULD DO THIS TO SAVE MEMORY, BUT WE WOULD NEED TO CHANGE generateEdges() METHOD.\r\n            //E.g currently we check if this.graph[y+1][x+1].nodeType !== 3, but when graph changes,\r\n            //that index won't be the the diagonial neighbour on the grid anymore, since the node is deleted\r\n            \r\n        }\r\n        //Check the other way around, if node used to be obstacle, add new neighbours to the node\r\n        else if(newNode.nodeType !== 3)\r\n        {\r\n            //Add the node to the graph\r\n            //Check if the node used to be an obstacle\r\n            if(Object.entries(this.adjacencyList[newNode.gridIndex]).length === 0)\r\n            {\r\n                this.adjacencyList[newNode.gridIndex] = {}\r\n                this.generateNodeNeighbours(newNode.gridIndex.toString())\r\n            }\r\n        }\r\n    }\r\n\r\n    calcMovementCost(node1, node2)\r\n    {\r\n        if(getIndex(node1)[0] === getIndex(node2)[0] || getIndex(node1)[1] === getIndex(node2)[1])\r\n            return 10\r\n        else\r\n            return 14\r\n    }\r\n\r\n    getWeight(node1, node2)\r\n    {\r\n        return this.adjacencyList[node1][node2];\r\n    }\r\n    \r\n    removeEdge(node1, node2)\r\n    {\r\n        node1 = node1.toString();\r\n        node2 = node2.toString();\r\n        delete this.adjacencyList[node1][node2]\r\n        delete this.adjacencyList[node2][node1]\r\n    }\r\n\r\n    //Function to add edges between two nodes\r\n    addEdge(nodeTuple){\r\n\r\n        let node1 = nodeTuple[0].toString()\r\n        let node2 = nodeTuple[1].toString()\r\n\r\n        //Check if there's already edge between nodes\r\n        for(var node in this.adjacencyList[node1])\r\n        {\r\n            if(node === node2)\r\n                return\r\n        }\r\n        let oldNeighbours;\r\n        \r\n        if(this.adjacencyList[node1] !== undefined)\r\n        {\r\n            //Get a dict of neighbours the node currently has\r\n            oldNeighbours = this.adjacencyList[node1]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node2] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node1] = oldNeighbours\r\n        }\r\n\r\n\r\n        if(this.adjacencyList[node2] !== undefined)\r\n        {\r\n            //Push node1 to node2's neighbours aswell\r\n            oldNeighbours = this.adjacencyList[node2]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node1] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node2] = oldNeighbours\r\n        }\r\n\r\n        return\r\n    }\r\n\r\n    //For creating the initial adjacency list from graph\r\n    initAdjList(){\r\n        //Iterate through graph node object array\r\n        for(var row = 0; row < this.graph.length; row++)\r\n        {\r\n            for(var col = 0; col < this.graph[row].length; col++)\r\n            {\r\n                //Node object's are stored in gridObject[1]\r\n                this.adjacencyList[this.graph[row][col][1].gridIndex] = {}\r\n            }\r\n        }\r\n        this.generateEdges();\r\n    }\r\n\r\n    generateNodeNeighbours(node)\r\n    {\r\n        let x = getIndex(node)[0]          //X max === this.graph[0]length 71\r\n        let y = getIndex(node)[1]          //Y max === this.graph.length 34\r\n\r\n        let node1 = [x,y]\r\n        var node2 = [0,0]\r\n        //If node is an obstacle, skip it\r\n        //TODO:: Consider just removing these from the graph ?\r\n        if(this.graph[y][x][1].nodeType === 3)\r\n            return\r\n        //this.graph has reversed x && y\r\n        //Origin of the graph is also in top left corner instead of bottom left corner which is the usual (TODO:: Change the point of origin?)\r\n        //Check edge cases and if the node is not obstacle for x && y axis\r\n        if(x-1 >= 0 && this.graph[y][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y];\r\n            this.addEdge([node1, node2])\r\n        }            \r\n        if(x+1 < this.graph[0].length && this.graph[y][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y-1 >= 0 && this.graph[y-1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y+1 < this.graph.length && this.graph[y+1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        //Diagonials\r\n        if(x-1 >= 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x-1 >= 0 && y-1 >= 0 && this.graph[y-1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y-1 >= 0 && this.graph[y-1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n    }\r\n\r\n    generateEdges(){\r\n        //Since we're using a grid what will always have neighbours in x-y and diagonial axis, we can just check whether those nodes are obstacles or not\r\n        //And add edges between those nodes\r\n        for(var node in this.adjacencyList)\r\n        {\r\n            this.generateNodeNeighbours(node)\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport default Graph;","export class Node{\r\n    constructor(x,y, weight){\r\n        this.gridIndex = [x,y];\r\n        this.nodeType= 0;\r\n        this.weight = weight;\r\n    }\r\n\r\n    addNeighbour(node){\r\n        this.neighbours.push(node);\r\n    }\r\n\r\n    setGridIndex(idx)\r\n    {\r\n        this.gridIndex = idx;\r\n    }\r\n\r\n    getGridIndex()\r\n    {\r\n        return this.gridIndex;\r\n    }\r\n\r\n    setType(type)\r\n    {\r\n        this.nodeType = type;\r\n    }\r\n\r\n    getType()\r\n    {\r\n        return this.nodeType;\r\n    }\r\n\r\n    removeNeighbour(node){\r\n        const index = this.neighbours.indexOf(node);\r\n        if(index > -1)\r\n        {\r\n            this.neighbours.splice(index, 1);\r\n            return node;\r\n        }\r\n    }\r\n\r\n    getNeighbours()\r\n    {\r\n        return this.neighbours;\r\n    }\r\n}\r\n\r\nexport default Node;","import {Node} from './Node'\r\nimport {getIndex} from './Utility'\r\n\r\nexport class PriorityQueue{\r\n    \r\n    constructor(props)\r\n    {\r\n        this.queue = []\r\n    }\r\n\r\n    queue_item(nodeIdx, priorityValue)\r\n    {\r\n        var [x,y] = getIndex(nodeIdx)\r\n        var qElem = new Node(x, y, priorityValue);\r\n        var doesContain = false;\r\n        \r\n        for(var i = 0; i < this.queue.length; i++)\r\n        {\r\n            if(this.queue[i].weight > qElem.weight)\r\n            {\r\n                this.queue.splice(i, 0, qElem)\r\n                doesContain = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!doesContain)\r\n            this.queue.push(qElem)\r\n    }\r\n\r\n    //We could hash the elements to get O(1) but we would still probably waste a lot of memory since the count of elements is high\r\n    //Consider using min heap ?\r\n    dequeue()\r\n    {\r\n        if(!this.isEmpty())\r\n        {\r\n            var node = this.queue.shift()\r\n            return node\r\n        }\r\n    }\r\n\r\n    isEmpty()\r\n    {\r\n        return this.queue.length > 0 ? false : true;\r\n    }\r\n}\r\n\r\nexport default PriorityQueue;","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes} from './Utility'\r\n\r\nexport default function Dijkstra(Adj, start, goal)\r\n{\r\n    if(!start)\r\n        console.log(\"start was not defined\")\r\n    if(!goal)\r\n        console.log(\"end was not defined\")\r\n    \r\n    var prioQ = new PriorityQueue();\r\n    var shortestPath = [] //Shortest path to goal node\r\n    var toBeVisited = {} //Closed set\r\n    var dist = []\r\n    var parent = []\r\n\r\n    for(var node in Adj)\r\n    {\r\n        dist[node] = Infinity\r\n        parent[node] = undefined\r\n    }\r\n\r\n    dist[start] = 0;\r\n    \r\n    for(var node in Adj)\r\n    {\r\n        prioQ.queue_item(node, dist[node])\r\n    }\r\n\r\n    while(!prioQ.isEmpty())\r\n    {\r\n        let qElem = prioQ.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [toBeVisited, shortestPath]\r\n        }\r\n        \r\n        //Iterate the neighbours and calculate their weights\r\n        for(var neighbour in Adj[minNode])\r\n        {\r\n            if(dist[neighbour] > dist[minNode] + Adj[minNode][neighbour])\r\n            {\r\n                dist[neighbour] = dist[minNode] + Adj[minNode][neighbour]\r\n                parent[neighbour] = minNode\r\n                //Update the priority of the node in priority queue\r\n                if(!toBeVisited[neighbour])\r\n                {\r\n                    prioQ.queue_item(neighbour, dist[neighbour])\r\n                    toBeVisited[neighbour] = dist[neighbour]\r\n                }\r\n            }\r\n        }\r\n            \r\n    }\r\n    \r\n    return toBeVisited, shortestPath\r\n}","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes, getIndex} from './Utility'\r\n\r\nfunction calcHeurestic(start, goal)\r\n{\r\n    var [x1,y1] = getIndex(start)\r\n    var [x2,y2] = getIndex(goal)\r\n    var dx = Math.abs(x1-x2)\r\n    var dy = Math.abs(y1-y2)\r\n    return (10 * (dx + dy) + (14 - 2 * 10) * Math.min(dx, dy))\r\n}\r\n\r\nexport default function Astar(Adj, start, goal)\r\n{\r\n    var openSet = new PriorityQueue();\r\n    var gScore = {}        //g score value for every node in graph\r\n    var parent = {}        //Predecessor of any given node in graph\r\n    var visitedNodes = []  //Closed set\r\n    var nodesInOrder = []  //For visualizer\r\n    var shortestPath = []  //The shortest path\r\n\r\n    //Initialize start node\r\n    openSet.queue_item(start, 0);\r\n    visitedNodes.push(start)\r\n    gScore[start] = 0;\r\n    parent[start] = undefined\r\n\r\n\r\n    while(!openSet.isEmpty())\r\n    {\r\n        let qElem = openSet.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        nodesInOrder[qElem.gridIndex] = gScore[qElem.gridIndex]\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [nodesInOrder, shortestPath]\r\n        }\r\n        \r\n        for(let neighbour in Adj[minNode])\r\n        {   \r\n            let next = getIndex(neighbour)\r\n            if(visitedNodes.includes(neighbour))\r\n                continue;\r\n            let newCost = gScore[minNode] + Adj[minNode][next]\r\n            if(!gScore[next] || newCost < gScore[next])\r\n            {                \r\n                parent[next] = minNode\r\n                //Calc the new fScore for the neighbour\r\n                gScore[next] = newCost\r\n                //Calculate f(n) (priority) for this new node\r\n                let weight = newCost + calcHeurestic(next, goal)\r\n                openSet.queue_item(next, weight)\r\n            }\r\n        }\r\n        visitedNodes.push(minNode.toString())\r\n    }\r\n\r\n    return;\r\n}","import {getIndex} from './Utility'\r\n\r\nexport default class Maze\r\n{\r\n    constructor(AdjList)\r\n    {\r\n        this.adj = AdjList\r\n        this.visitedNodes = []\r\n        this.init();\r\n    }\r\n\r\n    init()\r\n    {\r\n        //Initialize visited nodes 2d matrix\r\n        let nodes = Object.keys(this.adj)\r\n        var [maxRow,maxCol] = getIndex(nodes[nodes.length-1])\r\n        for(let i = 0; i <= maxCol; i++)\r\n        {\r\n            let tmpRow = []\r\n            for(let j = 0; j <= maxRow; j++)\r\n            {\r\n                tmpRow.push(false)\r\n            }\r\n            this.visitedNodes.push(tmpRow)\r\n        }\r\n        //Pick a node from the visited nodes, preferably from the top\r\n        this.generateMaze(nodes[0]);\r\n    }\r\n\r\n    generateMaze(nodeStr)\r\n    {\r\n        let node = getIndex(nodeStr);\r\n        //Mark the chosen node as visited\r\n        console.log(node)\r\n        this.visitedNodes[node[1]][node[0]] = true;\r\n        //Get the node's neighbours\r\n        let wallList = Object.keys(this.adj[nodeStr])\r\n        //Remove already visited neighbours, iterate in reverse since the indexes change when element is removed\r\n        for(let i = wallList.length-1; i >= 0; i--)\r\n        {\r\n            let nodeIdx = getIndex(wallList[i])\r\n            if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n            //Delete diagonial neighbours for the sake of cleaner maze\r\n            if(node[0] != nodeIdx[0] && node[1] != nodeIdx[1])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n        }\r\n        //Now the neighbours list only contains 'obstacle' nodes, that are neighbours with the chosen cell in x or y axis\r\n        //Iterate through the list\r\n        while(wallList.length > 0)\r\n        {\r\n            //Pick a random neighbour from the list\r\n            let wall = wallList[Math.floor(Math.random() * Math.floor(wallList.length))] \r\n            wall = getIndex(wall)\r\n            let visitedCounter = 0;\r\n            //Check if the chosen nodes doesn't have 2 explored neighbour nodes\r\n            let wallNeighbours = Object.keys(this.adj[wall.toString()])\r\n            for(let i = wallNeighbours.length-1; i >= 0; i--)\r\n            {\r\n                let nodeIdx = getIndex(wallNeighbours[i])\r\n                if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                    visitedCounter += 1;\r\n                }\r\n                //Delete diagonial neighbours for the sake of cleaner maze\r\n                if(wall[0] != nodeIdx[0] && wall[1] != nodeIdx[1])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            //Now wallNeighbours only contains the neighbours that are obstacles, aka walls \r\n            //Check for count of visited neighbours\r\n            if(visitedCounter <= 2)\r\n            {\r\n                this.visitedNodes[wall[1]][wall[0]] = true\r\n                for(let i = 0; i < wallNeighbours.length; i++)\r\n                {\r\n                    wallList.push(wallNeighbours[i])\r\n                }\r\n            }\r\n            wallList.splice(wallList.indexOf(wall.toString()), 1);\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport GridItem from './GridItem'\r\nimport Graph from '../PathfindingAlgorithms/Graph'\r\nimport Dijkstra from '../PathfindingAlgorithms/Dijkstra'\r\nimport Astar from '../PathfindingAlgorithms/Astar'\r\nimport Maze from '../PathfindingAlgorithms/Maze'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\nimport {compareNodes, getIndex, sleep} from '../PathfindingAlgorithms/Utility'\r\nimport './Grid.scss';\r\n\r\n\r\n//Current react layout is bad, we should've stored all this functionality in to a single component instead of two, Grid.jsx and PathfindingLayout.jsx\r\n//Now we need hacky methods to access child components states and call their functionality from parent component\r\nclass PathfindingLayout extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            gridRowCount: 0,                   \r\n            gridColCount: 0,\r\n\r\n            algorithm: undefined,\r\n            drawMode: undefined,\r\n            gridState: [],                   //Grid representation of node objects as 2d array\r\n            Graph: undefined,               //Graph representation of the grid (Adjacency list of the nodes and movement cost matrix)   \r\n\r\n            gridStartPos: undefined,\r\n            gridEndPos: undefined,\r\n            curGrid: undefined,             //Key of the current grid, for resetting the grid\r\n\r\n            isVisualized: false,\r\n            isAnimating: false,\r\n            animationSpeed: 50,                 //Animation speed in ms\r\n\r\n            showWeights: false,\r\n        }\r\n        this.handleAlgorithmModeChange = this.handleAlgorithmModeChange.bind(this);\r\n        this.handleDrawModeChange = this.handleDrawModeChange.bind(this);\r\n        this.handleResetClick = this.handleResetClick.bind(this);\r\n        this.handleSimulateClick = this.handleSimulateClick.bind(this);\r\n        this.generateMaze = this.generateMaze.bind(this);\r\n        this.animate = this.animate.bind(this);\r\n        this.AlgorithmTypes = Object.freeze({\r\n            Dijkstra,\r\n            Astar,\r\n        })\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.setState({algorithm: this.AlgorithmTypes.Dijkstra, drawMode: 1});\r\n        this.initGrid();\r\n    }\r\n\r\n    //Resets the whole grid\r\n    //TODO:: Instead of iterating through the whole grid, we could just store the nodes that need to be cleared into a state as an array, would increase performance by a quite a bit.\r\n    async handleResetClick(){\r\n        //Creating a new key for our grid component recreates the component from scratch. Since we only have one component using math.random should be fine\r\n        let newId = Math.random()\r\n        //this.cancelAnimation();\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        var oldGrid = [...this.state.gridState]\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                var oldNode = oldGrid[i][j][1]\r\n                oldNode.nodeType = 0;\r\n                oldNode.weight = 0;\r\n                var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                oldGrid[i][j][0] = oldGridItem\r\n            }\r\n        }\r\n        var newGraph = new Graph(this.state.gridState)\r\n        this.setState({curGrid: newId, gridState: oldGrid, Graph: newGraph, gridStartPos: undefined, gridEndPos: undefined})\r\n    }\r\n\r\n    handleSpeedSlider = (e) =>\r\n    {\r\n        this.setState({animationSpeed: e.target.value})\r\n    }\r\n\r\n    handleCheckboxChange = (e) => \r\n    {\r\n        this.setState({showWeights: e.target.value})\r\n    }\r\n\r\n    cancelAnimation()\r\n    {\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        let oldGrid = [...this.state.gridState]\r\n        let oldGraph = this.state.Graph\r\n        //This is atleast o(n^2) and is very costly way of cancelling the animation, maybe store the animated nodes to a heap instead of iterating through whole matrix\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                if(oldGrid[i][j][0].props.visited)\r\n                {\r\n                    var oldNode = oldGrid[i][j][1]\r\n                    oldNode.nodeType = 0;\r\n                    var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                    oldGrid[i][j][0] = oldGridItem\r\n                    oldGraph.updateNode(oldNode)\r\n                }\r\n            }\r\n        }\r\n        this.setState({gridState: oldGrid, Graph: oldGraph})\r\n        console.log(\"animation cancelled!\")\r\n    }\r\n\r\n    async handleSimulateClick(){\r\n        //Check if the grid in in animated state\r\n        if(this.state.isVisualized || this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n            await sleep(1);\r\n        }\r\n\r\n        if(this.state.gridState && this.state.gridStartPos && this.state.gridEndPos)\r\n        {\r\n            const start = this.state.gridStartPos.state.node.gridIndex\r\n            const goal = this.state.gridEndPos.state.node.gridIndex\r\n            //Call selected algorithm\r\n            //Create instance of the selected algorithm object\r\n            switch(this.state.algorithm)\r\n            {\r\n                case this.AlgorithmTypes.Dijkstra:\r\n                    var dijkstra = Dijkstra(this.state.Graph.adjacencyList, start, goal);\r\n                    this.animate(dijkstra[0], dijkstra[1])\r\n                    break;\r\n                case this.AlgorithmTypes.Astar:\r\n                    var astar = Astar(this.state.Graph.adjacencyList, start, goal)\r\n                    this.animate(astar[0], astar[1])\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.log(\"Grid was undefined\")\r\n        }\r\n    }\r\n\r\n    //Takes nodes to animate in array that's ordered\r\n    //nodesInOrder[0] is the node index and [1] is the weight of the node\r\n    async animate(nodesInOrder, shortestPath)\r\n    {\r\n        console.log(\"Animation started\");\r\n\r\n        await this.setState({isAnimating: true})\r\n\r\n        //Animate visitedNodes\r\n        let oldGrid = [...this.state.gridState];\r\n        for(const [nodeIdx, weight] of Object.entries(nodesInOrder))\r\n        {\r\n            await sleep(100 - this.state.animationSpeed);\r\n            if(!this.state.isAnimating)\r\n                return\r\n\r\n            //Get the index of the node, nodesInOrder is an array of strings instead of numbers (Because we're using js and not ts...)\r\n            var [x,y] = getIndex(nodeIdx)\r\n\r\n            //No need to animate the goal node\r\n            if(compareNodes([x,y], this.state.gridEndPos.state.node.gridIndex) || compareNodes([x,y], this.state.gridStartPos.state.node.gridIndex))\r\n                continue\r\n            var gridItem = oldGrid[y][x][0]\r\n\r\n            //Create inline style object depending on the weight value \r\n            let c = [0,191,255]     //rgb\r\n            c[0] += weight/3;\r\n            c[1] -= weight/3*2;\r\n            c[2] -= weight/3*2;\r\n\r\n            const _styleObj = {\r\n                'background-color': 'rgb('+c[0]+','+c[1]+','+c[2]+')'\r\n            };\r\n\r\n            //Clone/Duplicate the gridItem component with new properties and overwrite the old one\r\n            let newGridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-visited', styleObj: _styleObj, weight: weight, showWeight: this.state.showWeights});\r\n            oldGrid[y][x][0] = newGridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        \r\n        //Animate shortest path in the end, no need to animate start or goal\r\n        for(let i = 1; i < shortestPath.length-1; i++)\r\n        {\r\n            await sleep(100 - this.state.animationSpeed)\r\n            if(!this.state.isAnimating)\r\n                return\r\n            let [x,y] = getIndex(shortestPath[i])\r\n            let gridItem = oldGrid[y][x][0]\r\n\r\n            gridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-shortestPath', styleObj: undefined});\r\n            oldGrid[y][x][0] = gridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        this.setState({gridState: oldGrid, isVisualized: true, isAnimated: false})\r\n    }\r\n\r\n    //Recursive maze generation\r\n    async generateMaze()\r\n    {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating || this.state.isVisualized)\r\n        {\r\n            //Since we don't need to clear the \"Visited nodes\" here, we can simply just reset the whole grid\r\n            this.handleResetClick();\r\n            await sleep(10);\r\n        }\r\n        //Generate maze from the current grid state\r\n        var maze = new Maze(this.state.Graph.adjacencyList);\r\n        await this.setState({isAnimating: true})\r\n        for(var x = 0; x < maze.visitedNodes.length; x++)\r\n        {\r\n            for(var y = 0; y < maze.visitedNodes[x].length; y++)\r\n            {\r\n                if(!this.state.isAnimating)\r\n                {\r\n                    this.setState({isVisualized: true})\r\n                    console.log(this.state.isVisualized)\r\n                    console.log(\"Cancelled\")\r\n                    await sleep(10);\r\n                    return\r\n                }\r\n                //If node is false, it's an obstacle\r\n                if(maze.visitedNodes[x][y] === false)\r\n                {\r\n                    let newGrid = this.state.gridState\r\n                    //Update the gridItem and the node in gridState\r\n                    await this.updateGridItem([y,x], newGrid[x][y][1], 3);\r\n                    //Sleep for a bit before next iteration\r\n                    await sleep(100 - this.state.animationSpeed);\r\n                }\r\n            }\r\n        }\r\n        this.setState({isAnimating: false, isVisualized: true})\r\n    }\r\n\r\n    handleAlgorithmModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"Dijkstra\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n            case \"Astar\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Astar})\r\n                break;\r\n            case \"BFS\":\r\n                this.setState({algorithm: this.AlgorithmTypes.BFS})\r\n                break;\r\n            default:\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleDrawModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"start\":\r\n                this.setState({drawMode: 1})\r\n                break;\r\n            case \"end\":\r\n                this.setState({drawMode: 2})\r\n                break;\r\n            case \"obstacle\":\r\n                this.setState({drawMode: 3})\r\n                break;\r\n            default:\r\n                this.setState({drawMode: 1})\r\n                break;\r\n        }\r\n        //TODO:: Handle diff types as enums\r\n        console.log(\"this changed to \" + e.target.value);\r\n    }\r\n\r\n    gridWasClicked = (gridItem) => {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n        }\r\n        //Check if the clicked node was already the selected type\r\n        if(gridItem.state.node.nodeType === this.state.drawMode)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        let newNode = gridItem.state.node;\r\n        switch(this.state.drawMode)\r\n        {\r\n            //Draw mode is start\r\n            case 1:\r\n                if(this.state.gridStartPos)\r\n                {\r\n                    //Create temporary copy of the current start position node (Found by index from gridState array), so we don't mutate the active node directly\r\n                    let oldX = this.state.gridStartPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridStartPos.state.node.gridIndex[1]\r\n                    let oldStartNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldStartNode.nodeType = 0;\r\n                    \r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldStartNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new starting point\r\n                newNode.nodeType = 1\r\n                this.updateGridItem(newNode.gridIndex, newNode, 1);\r\n                //Update the grid starting position\r\n                this.setState({gridStartPos: gridItem})\r\n                break;\r\n            //Draw mode is end\r\n            case 2:\r\n                if(this.state.gridEndPos)\r\n                {\r\n                    //Create temporary copy of the current node\r\n                    let oldX = this.state.gridEndPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridEndPos.state.node.gridIndex[1]\r\n                    let oldEndNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldEndNode.nodeType = 0;\r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldEndNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new ending point\r\n                newNode.nodeType = 2\r\n                this.updateGridItem(newNode.gridIndex, newNode, 2);\r\n                //Update the grid starting position\r\n                this.setState({gridEndPos: gridItem})\r\n                break;\r\n            //Draw mode is obstacle\r\n            case 3:\r\n                newNode.nodeType = this.state.drawMode;\r\n                this.updateGridItem(newNode.gridIndex, newNode, 3);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    updateGridItem(idx, node, nodeType)\r\n    {\r\n        let oldGridState = [...this.state.gridState]\r\n        let _styleName = \"\" \r\n        switch(nodeType)\r\n        {\r\n            case 1:\r\n                _styleName = 'grid-item-start';\r\n                break;\r\n            case 2:\r\n                _styleName = 'grid-item-end';\r\n                break;\r\n            case 3:\r\n                _styleName = 'grid-item-obstacle';\r\n                break;\r\n            default:\r\n                _styleName = 'grid-item'\r\n                break;\r\n        }\r\n\r\n        let oldGridItem = React.cloneElement(oldGridState[idx[1]][idx[0]][0], {itemNode: node, styleName: _styleName});\r\n        oldGridState[idx[1]][idx[0]][0] = oldGridItem\r\n        node.nodeType = nodeType;       //For some reason the node's type isn't always the same as the parameter\r\n        oldGridState[idx[1]][idx[0]][1] = node\r\n\r\n        //Update the node in adjacency list aswell\r\n        let tmpGraph = this.state.Graph\r\n        tmpGraph.updateNode(node)\r\n        this.setState({gridState: oldGridState, Graph: tmpGraph})\r\n    }\r\n\r\n    pushElemsToGrid(elem){\r\n        let tmpArr = this.state.gridState;\r\n        tmpArr.push(elem);\r\n        this.setState({gridState: tmpArr});\r\n    }\r\n\r\n    initGrid()\r\n    {\r\n        //By calculating window.innerWidth/Heigth we could divide it by width/heigth of a GridItem and get the count to fill out the container\r\n        //Get the window dimensions\r\n        let width = window.innerWidth;\r\n        let height = window.innerHeight;\r\n        //14 px is the width and height of a GridItem component's rendered div\r\n        let colCount = Math.floor((width - 14) / 26);\r\n        let rowCount = Math.floor((height - 14) / 26);\r\n        console.log(colCount, rowCount)\r\n        //Store these values in state just in case we would want to implement grid resizing dynamically with window size.\r\n        this.setState({gridColCount: colCount, gridRowCount: rowCount});\r\n\r\n        let counter = 0;\r\n        for(let row = 0; row < rowCount; row++)\r\n        {\r\n            let tmpRow = [];\r\n            for(let col = 0; col < colCount; col++)\r\n            {\r\n                //Create node object array which represents the grid's state (Used for data processing) and GridItem array which is used to render the grid\r\n                let node = new Node(col, row, 0);\r\n                var bool = false;\r\n                tmpRow.push([<GridItem key={counter} gridWasClicked={this.gridWasClicked} itemNode={node} styleName='grid-item' visited={bool}/>, node]);\r\n                \r\n                counter++;\r\n            }\r\n            this.pushElemsToGrid(tmpRow);\r\n        }\r\n        this.setState({Graph: new Graph(this.state.gridState)})\r\n    }\r\n\r\n    render(){\r\n        const grid = this.state.gridState ? this.state.gridState : [[1]]\r\n        return(\r\n            <div className=\"layout-container\">\r\n                <nav className=\"layout-nav-bar\">\r\n                    <button className=\"layout-nav-button\" onClick={this.handleSimulateClick}>\r\n                        Simulate\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.generateMaze}>\r\n                        Generate maze\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.handleResetClick}>\r\n                        Reset\r\n                    </button>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Algorithm mode</label>\r\n                        <select name=\"algorithmMode\" id=\"algorithm_mode\" className=\"selector-dropdown\" onChange={this.handleAlgorithmModeChange}>\r\n                            <option value=\"Dijkstra\">Dijkstra</option>\r\n                            <option value=\"Astar\">A*</option>\r\n                        </select>\r\n                    </div>\r\n                    {/* Checkbox container for displaying weights, not ready for use yet */}\r\n                    {/* <div className=\"checkbox-container\">\r\n                        <label className=\"slider-description\">Show weights: </label>\r\n                        <input type=\"checkbox\" onChange={this.handleCheckboxChange}/>\r\n                    </div> */}\r\n                    <div className=\"slider-container\">\r\n                        <label className=\"slider-description\">Animation speed: {this.state.animationSpeed}</label>\r\n                        <input onChange={this.handleSpeedSlider} type=\"range\" className=\"animation-speed-slider\" min=\"1\" max=\"100\" value={this.state.animationSpeed}/>\r\n                    </div>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Drawing mode</label>\r\n                        <select name=\"drawingMode\" id=\"drawing_mode\" className=\"selector-dropdown\" onChange={this.handleDrawModeChange}>\r\n                            <option value=\"start\">Start location</option>\r\n                            <option value=\"end\">End location</option>\r\n                            <option value=\"obstacle\">Obstacle</option>\r\n                        </select>\r\n                    </div>\r\n                </nav>\r\n            <div>\r\n                <div key={this.state.curGrid} className=\"grid-container\">\r\n                    {grid.map((row, id) => <div key={id} className=\"grid-row\">{(row.map((item, id) => item[0]))}</div>)}\r\n                </div>\r\n            </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingLayout;","import React from 'react';\r\nimport PathfindingLayout from \"./PathfindingLayout\";\r\nimport './Layout.scss';\r\n\r\nclass Layout extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            currentLayout: <PathfindingLayout/>,\r\n        };\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div className=\"layout-wrapper\">\r\n                {this.state.currentLayout}\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default Layout;","import './App.css';\nimport Layout from './Components/Layout'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Layout/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}