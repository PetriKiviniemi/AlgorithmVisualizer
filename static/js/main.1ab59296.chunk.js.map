{"version":3,"sources":["Components/GridItem.jsx","PathfindingAlgorithms/Utility.js","PathfindingAlgorithms/Graph.jsx","PathfindingAlgorithms/Node.jsx","PathfindingAlgorithms/PriorityQueue.jsx","PathfindingAlgorithms/Dijkstra.js","PathfindingAlgorithms/Astar.js","PathfindingAlgorithms/Maze.js","Components/PathfindingLayout.jsx","Components/Layout.jsx","App.js","index.js"],"names":["GridItem","props","cellWasHovered","e","preventDefault","buttons","gridWasClicked","document","selection","empty","window","getSelection","removeAllRanges","cellWasClicked","itemDiv","React","createRef","state","node","styleName","styleObj","showWeight","weight","nodeObj","this","itemNode","setState","prevProps","isConstructed","visited","styleColor","undefined","className","style","onClick","onMouseOver","Component","getIndex","parseInt","split","compareNodes","node1","node2","sleep","ms","Promise","resolve","setTimeout","Graph","graph","adjacencyList","start","goal","initAdjList","newNode","gridIndex","nodeType","removeEdge","x","y","length","Object","entries","generateNodeNeighbours","toString","nodeTuple","oldNeighbours","calcMovementCost","row","col","generateEdges","addEdge","Node","neighbours","push","idx","type","index","indexOf","splice","PriorityQueue","queue","nodeIdx","priorityValue","qElem","doesContain","i","isEmpty","shift","Dijkstra","Adj","console","log","prioQ","shortestPath","toBeVisited","dist","parent","Infinity","queue_item","minNode","dequeue","neighbour","calcHeurestic","x1","y1","x2","y2","dx","Math","abs","dy","min","Astar","openSet","gScore","visitedNodes","nodesInOrder","next","includes","newCost","Maze","AdjList","adj","init","nodes","keys","maxRow","maxCol","tmpRow","j","generateMaze","nodeStr","wallList","wall","floor","random","visitedCounter","wallNeighbours","PathfindingLayout","handleSpeedSlider","animationSpeed","target","value","handleCheckboxChange","showWeights","gridItem","isAnimating","cancelAnimation","drawMode","gridStartPos","oldX","oldY","oldStartNode","gridState","updateGridItem","gridEndPos","oldEndNode","gridRowCount","gridColCount","algorithm","curGrid","isVisualized","handleAlgorithmModeChange","bind","handleDrawModeChange","handleResetClick","handleSimulateClick","animate","AlgorithmTypes","freeze","initGrid","newId","oldGrid","oldNode","oldGridItem","cloneElement","newGraph","oldGraph","updateNode","dijkstra","astar","c","_styleObj","newGridItem","isAnimated","maze","newGrid","oldGridState","_styleName","tmpGraph","elem","tmpArr","width","innerWidth","height","innerHeight","colCount","rowCount","counter","pushElemsToGrid","grid","name","id","onChange","max","map","item","Layout","currentLayout","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.1ab59296.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Grid.scss'\r\n\r\n//Just an object thats state is controlled by the grid\r\n//Used for animation and visualization only\r\nclass GridItem extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.itemDiv = React.createRef();\r\n        this.state = {\r\n            node: this.props.node,                  //Node object that's stored in this gridItem component. TODO:: Store all node objects in parent and then just pass their needed values as props to this component\r\n            styleName: this.props.styleName,        //Css style name what is changed with selecte drawing mode\r\n            styleObj: this.props.styleObj,          //Inline style object that's passed as a prop from parent, used to calculate the RGB color of the node from the weight value\r\n            showWeight: this.props.showWeight,      //This is a boolean for showing weights, has currently no use\r\n            weight: this.props.weight               //The actual weight value of the node after running desired algorithm\r\n        };\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        let nodeObj = this.props.itemNode\r\n        this.setState({node: nodeObj, styleName: this.props.styleName, styleObj: this.props.styleObj, showWeight: this.props.showWeight, weight: this.props.weight});\r\n    }\r\n\r\n    componentDidUpdate(prevProps)\r\n    {\r\n        if(this.props.showWeight !== prevProps.showWeight)\r\n            this.setState({showWeight: this.props.showWeight})\r\n        if(this.props.styleName !== prevProps.styleName)\r\n            this.setState({styleName: this.props.styleName})\r\n    }\r\n\r\n    //Handle cell hover over if mouse buttons are being pressed down, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasHovered = (e) => {\r\n        e.preventDefault();\r\n        var unFocus = function () {\r\n            if (document.selection) {\r\n              document.selection.empty()\r\n            } else {\r\n              window.getSelection().removeAllRanges()\r\n            }\r\n        } \r\n        //If the mouse buttons are being held down\r\n        if(e.buttons === 1 || e.buttons === 3)\r\n        {\r\n            \r\n            this.props.gridWasClicked(this);\r\n            unFocus();\r\n        }\r\n    }\r\n\r\n    //Handle cell click, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasClicked = (e) => {\r\n        e.preventDefault();\r\n        this.props.gridWasClicked(this);\r\n    }\r\n\r\n    render(){\r\n        //Variables that change depending on the passed props\r\n        let isConstructed = this.state.node ? true : false;\r\n        let styleName = this.props.visited ? this.props.styleName : this.state.styleName\r\n        let styleColor = this.props.visited ? this.props.styleObj : undefined\r\n        //let weightValue = this.props.showWeight ? this.state.weight : \"\"      //This can be used to display weights of the nodes\r\n        if(isConstructed)\r\n        {\r\n            return(\r\n                <div className={styleName} style={styleColor} onClick={this.cellWasClicked} onMouseOver={this.cellWasHovered}>    \r\n                </div> \r\n            ); \r\n        }\r\n        else{\r\n            return(<div/>)\r\n        }\r\n    }\r\n}\r\n\r\nexport default GridItem;","export function getIndex(node)\r\n{\r\n    //Since the grid index is stored a string in the node\r\n    //This quick hack function will always return the node's index value as integer\r\n    //check if nodeIdx is string or int array\r\n    if(typeof node != \"string\")\r\n        return node\r\n    let x = parseInt(node.split(',')[0])\r\n    let y = parseInt(node.split(',')[1])\r\n    return [x,y]\r\n}\r\n\r\nexport function compareNodes(node1, node2)\r\n{\r\n    if(node1[0] === node2[0] && node1[1] === node2[1])\r\n        return true\r\n    else\r\n        return false\r\n}\r\n\r\nexport function sleep(ms)\r\n{\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}","import {getIndex} from './Utility'\r\n\r\nexport default class Graph{\r\n    \r\n    constructor(graph)\r\n    {\r\n        this.graph = graph;\r\n        this.adjacencyList = {}\r\n        this.start = undefined;\r\n        this.goal = undefined;\r\n        //this.adjacencyList is adjacency list (key value paired dict type object) of nodes\r\n        /** For example\r\n        graph = {\r\n                node1: {node2 : 10, node3 : 14},\r\n                node2: ...,\r\n                }\r\n         */\r\n        this.initAdjList();\r\n    }\r\n\r\n    //Function for updating nodes after the graph is initialized\r\n    //E.g a node in graph changes to an obstacle, we remove edges between this node and it's neighbours, and delete the node after\r\n    updateNode(newNode)\r\n    {\r\n        //First update the node\r\n        this.graph[newNode.gridIndex[1]][newNode.gridIndex[0]][1] = newNode\r\n        //Check if the newly changed node was obstacle, if it was\r\n        //Remove the edges from this node to anywhere else\r\n        //We could also check if the node used to be an obstacle, then we would have no operations to perform\r\n        if(newNode.nodeType === 3)\r\n        {\r\n            for(var node in this.adjacencyList[newNode.gridIndex])\r\n            {\r\n                //Remove edges node->neighbour and neighbour->node\r\n                this.removeEdge(newNode.gridIndex, node)\r\n            }\r\n            \r\n            //Check diagonials if they're obstacles, if they're, remove edges between the non-obstacle nodes from x & y axis\r\n            var [x,y] = newNode.gridIndex\r\n            //x max = this.graph.length, x === row\r\n            //Check if col and row is out of bounds aswell\r\n            //Top right\r\n            if(x+1 < this.graph[0].length && y-1 > 0 && this.graph[y-1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x+1, y])\r\n            }\r\n            //Bottom right\r\n            if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x+1,y], [x, y+1])\r\n            }\r\n            //Bottom left\r\n            if(x-1 > 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x-1,y], [x, y+1])\r\n            }\r\n            //Top left\r\n            if(x-1 > 0 && y-1 > 0 && this.graph[y-1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x-1, y])\r\n            }\r\n\r\n\r\n            //Remove the node from graph\r\n            //delete this.adjacencyList[newNode.gridIndex]\r\n            \r\n            //TODO:: WE COULD DO THIS TO SAVE MEMORY, BUT WE WOULD NEED TO CHANGE generateEdges() METHOD.\r\n            //E.g currently we check if this.graph[y+1][x+1].nodeType !=== 3, but when graph changes,\r\n            //that index won't be the the diagonial neighbour on the grid anymore, since the node is deleted\r\n            \r\n        }\r\n        //Check the other way around, if node used to be obstacle, add new neighbours to the node\r\n        else if(newNode.nodeType !== 3)\r\n        {\r\n            //Add the node to the graph\r\n            //Check if the node used to be an obstacle\r\n            if(Object.entries(this.adjacencyList[newNode.gridIndex]).length === 0)\r\n            {\r\n                this.adjacencyList[newNode.gridIndex] = {}\r\n                this.generateNodeNeighbours(newNode.gridIndex.toString())\r\n            }\r\n        }\r\n    }\r\n\r\n    calcMovementCost(node1, node2)\r\n    {\r\n        if(getIndex(node1)[0] === getIndex(node2)[0] || getIndex(node1)[1] === getIndex(node2)[1])\r\n            return 10\r\n        else\r\n            return 14\r\n    }\r\n\r\n    getWeight(node1, node2)\r\n    {\r\n        return this.adjacencyList[node1][node2];\r\n    }\r\n    \r\n    removeEdge(node1, node2)\r\n    {\r\n        node1 = node1.toString();\r\n        node2 = node2.toString();\r\n        delete this.adjacencyList[node1][node2]\r\n        delete this.adjacencyList[node2][node1]\r\n    }\r\n\r\n    //Function to add edges between two nodes\r\n    addEdge(nodeTuple){\r\n\r\n        let node1 = nodeTuple[0].toString()\r\n        let node2 = nodeTuple[1].toString()\r\n\r\n        //Check if there's already edge between nodes\r\n        for(var node in this.adjacencyList[node1])\r\n        {\r\n            if(node === node2)\r\n                return\r\n        }\r\n        let oldNeighbours;\r\n        \r\n        if(this.adjacencyList[node1] !== undefined)\r\n        {\r\n            //Get a dict of neighbours the node currently has\r\n            oldNeighbours = this.adjacencyList[node1]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node2] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node1] = oldNeighbours\r\n        }\r\n\r\n\r\n        if(this.adjacencyList[node2] !== undefined)\r\n        {\r\n            //Push node1 to node2's neighbours aswell\r\n            oldNeighbours = this.adjacencyList[node2]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node1] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node2] = oldNeighbours\r\n        }\r\n\r\n        return\r\n    }\r\n\r\n    //For creating the initial adjacency list from graph\r\n    initAdjList(){\r\n        //Iterate through graph node object array\r\n        for(var row = 0; row < this.graph.length; row++)\r\n        {\r\n            for(var col = 0; col < this.graph[row].length; col++)\r\n            {\r\n                //Node object's are stored in gridObject[1]\r\n                this.adjacencyList[this.graph[row][col][1].gridIndex] = {}\r\n            }\r\n        }\r\n        this.generateEdges();\r\n    }\r\n\r\n    generateNodeNeighbours(node)\r\n    {\r\n        let x = getIndex(node)[0]          //X max == this.graph[0]length 71\r\n        let y = getIndex(node)[1]          //Y max == this.graph.length 34\r\n\r\n        let node1 = [x,y]\r\n        var node2 = [0,0]\r\n        //If node is an obstacle, skip it\r\n        //TODO:: Consider just removing these from the graph ?\r\n        if(this.graph[y][x][1].nodeType === 3)\r\n            return\r\n        //this.graph has reversed x && y\r\n        //Origin of the graph is also in top left corner instead of bottom left corner which is the usual (TODO:: Change the point of origin?)\r\n        //Check edge cases and if the node is not obstacle for x && y axis\r\n        if(x-1 >= 0 && this.graph[y][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y];\r\n            this.addEdge([node1, node2])\r\n        }            \r\n        if(x+1 < this.graph[0].length && this.graph[y][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y-1 >= 0 && this.graph[y-1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y+1 < this.graph.length && this.graph[y+1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        //Diagonials\r\n        if(x-1 >= 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x-1 >= 0 && y-1 >= 0 && this.graph[y-1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y-1 >= 0 && this.graph[y-1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n    }\r\n\r\n    generateEdges(){\r\n        //Since we're using a grid what will always have neighbours in x-y and diagonial axis, we can just check whether those nodes are obstacles or not\r\n        //And add edges between those nodes\r\n        for(var node in this.adjacencyList)\r\n        {\r\n            this.generateNodeNeighbours(node)\r\n        }\r\n    }\r\n\r\n}","export default class Node{\r\n    constructor(x,y, weight){\r\n        this.gridIndex = [x,y];\r\n        this.nodeType= 0;\r\n        this.weight = weight;\r\n    }\r\n\r\n    addNeighbour(node){\r\n        this.neighbours.push(node);\r\n    }\r\n\r\n    setGridIndex(idx)\r\n    {\r\n        this.gridIndex = idx;\r\n    }\r\n\r\n    getGridIndex()\r\n    {\r\n        return this.gridIndex;\r\n    }\r\n\r\n    setType(type)\r\n    {\r\n        this.nodeType = type;\r\n    }\r\n\r\n    getType()\r\n    {\r\n        return this.nodeType;\r\n    }\r\n\r\n    removeNeighbour(node){\r\n        const index = this.neighbours.indexOf(node);\r\n        if(index > -1)\r\n        {\r\n            this.neighbours.splice(index, 1);\r\n            return node;\r\n        }\r\n    }\r\n\r\n    getNeighbours()\r\n    {\r\n        return this.neighbours;\r\n    }\r\n}","import Node from './Node'\r\nimport {getIndex} from './Utility'\r\n\r\nexport class PriorityQueue{\r\n    \r\n    constructor(props)\r\n    {\r\n        this.queue = []\r\n    }\r\n\r\n    queue_item(nodeIdx, priorityValue)\r\n    {\r\n        var [x,y] = getIndex(nodeIdx)\r\n        var qElem = new Node(x, y, priorityValue);\r\n        var doesContain = false;\r\n        \r\n        for(var i = 0; i < this.queue.length; i++)\r\n        {\r\n            if(this.queue[i].weight > qElem.weight)\r\n            {\r\n                this.queue.splice(i, 0, qElem)\r\n                doesContain = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!doesContain)\r\n            this.queue.push(qElem)\r\n    }\r\n\r\n    //We could hash the elements to get O(1) but we would still probably waste a lot of memory since the count of elements is high\r\n    //Consider using min heap ?\r\n    dequeue()\r\n    {\r\n        if(!this.isEmpty())\r\n        {\r\n            var node = this.queue.shift()\r\n            return node\r\n        }\r\n    }\r\n\r\n    isEmpty()\r\n    {\r\n        return this.queue.length > 0 ? false : true;\r\n    }\r\n}\r\n\r\nexport default PriorityQueue;","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes} from './Utility'\r\n\r\nexport default function Dijkstra(Adj, start, goal)\r\n{\r\n    if(!start)\r\n        console.log(\"start was not defined\")\r\n    if(!goal)\r\n        console.log(\"end was not defined\")\r\n    \r\n    var prioQ = new PriorityQueue();\r\n    var shortestPath = [] //Shortest path to goal node\r\n    var toBeVisited = {} //Closed set\r\n    var dist = []\r\n    var parent = []\r\n\r\n    for(let node in Adj)\r\n    {\r\n        dist[node] = Infinity\r\n        parent[node] = undefined\r\n    }\r\n\r\n    dist[start] = 0;\r\n    \r\n    for(let node in Adj)\r\n    {\r\n        prioQ.queue_item(node, dist[node])\r\n    }\r\n\r\n    while(!prioQ.isEmpty())\r\n    {\r\n        let qElem = prioQ.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode !== undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [toBeVisited, shortestPath]\r\n        }\r\n        \r\n        //Iterate the neighbours and calculate their weights\r\n        for(var neighbour in Adj[minNode])\r\n        {\r\n            if(dist[neighbour] > dist[minNode] + Adj[minNode][neighbour])\r\n            {\r\n                dist[neighbour] = dist[minNode] + Adj[minNode][neighbour]\r\n                parent[neighbour] = minNode\r\n                //Update the priority of the node in priority queue\r\n                if(!toBeVisited[neighbour])\r\n                {\r\n                    prioQ.queue_item(neighbour, dist[neighbour])\r\n                    toBeVisited[neighbour] = dist[neighbour]\r\n                }\r\n            }\r\n        }\r\n            \r\n    }\r\n    \r\n    return [toBeVisited, shortestPath]\r\n}","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes, getIndex} from './Utility'\r\n\r\nfunction calcHeurestic(start, goal)\r\n{\r\n    var [x1,y1] = getIndex(start)\r\n    var [x2,y2] = getIndex(goal)\r\n    var dx = Math.abs(x1-x2)\r\n    var dy = Math.abs(y1-y2)\r\n    return (10 * (dx + dy) + (14 - 2 * 10) * Math.min(dx, dy))\r\n}\r\n\r\nexport default function Astar(Adj, start, goal)\r\n{\r\n    var openSet = new PriorityQueue();\r\n    var gScore = {}        //g score value for every node in graph\r\n    var parent = {}        //Predecessor of any given node in graph\r\n    var visitedNodes = []  //Closed set\r\n    var nodesInOrder = []  //For visualizer\r\n    var shortestPath = []  //The shortest path\r\n\r\n    //Initialize start node\r\n    openSet.queue_item(start, 0);\r\n    visitedNodes.push(start)\r\n    gScore[start] = 0;\r\n    parent[start] = undefined\r\n\r\n\r\n    while(!openSet.isEmpty())\r\n    {\r\n        let qElem = openSet.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        nodesInOrder[qElem.gridIndex] = gScore[qElem.gridIndex]\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode !== undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [nodesInOrder, shortestPath]\r\n        }\r\n        \r\n        for(let neighbour in Adj[minNode])\r\n        {   \r\n            let next = getIndex(neighbour)\r\n            if(visitedNodes.includes(neighbour))\r\n                continue;\r\n            let newCost = gScore[minNode] + Adj[minNode][next]\r\n            if(!gScore[next] || newCost < gScore[next])\r\n            {                \r\n                parent[next] = minNode\r\n                //Calc the new fScore for the neighbour\r\n                gScore[next] = newCost\r\n                //Calculate f(n) (priority) for this new node\r\n                let weight = newCost + calcHeurestic(next, goal)\r\n                openSet.queue_item(next, weight)\r\n            }\r\n        }\r\n        visitedNodes.push(minNode.toString())\r\n    }\r\n\r\n    return;\r\n}","import {getIndex} from './Utility'\r\n\r\nexport default class Maze\r\n{\r\n    constructor(AdjList)\r\n    {\r\n        this.adj = AdjList\r\n        this.visitedNodes = []\r\n        this.init();\r\n    }\r\n\r\n    init()\r\n    {\r\n        //Initialize visited nodes 2d matrix\r\n        let nodes = Object.keys(this.adj)\r\n        var [maxRow,maxCol] = getIndex(nodes[nodes.length-1])\r\n        for(let i = 0; i <= maxCol; i++)\r\n        {\r\n            let tmpRow = []\r\n            for(let j = 0; j <= maxRow; j++)\r\n            {\r\n                tmpRow.push(false)\r\n            }\r\n            this.visitedNodes.push(tmpRow)\r\n        }\r\n        //Pick a node from the visited nodes, preferably from the top\r\n        this.generateMaze(nodes[0]);\r\n    }\r\n\r\n    generateMaze(nodeStr)\r\n    {\r\n        let node = getIndex(nodeStr);\r\n        //Mark the chosen node as visited\r\n        console.log(node)\r\n        this.visitedNodes[node[1]][node[0]] = true;\r\n        //Get the node's neighbours\r\n        let wallList = Object.keys(this.adj[nodeStr])\r\n        //Remove already visited neighbours, iterate in reverse since the indexes change when element is removed\r\n        for(let i = wallList.length-1; i >= 0; i--)\r\n        {\r\n            let nodeIdx = getIndex(wallList[i])\r\n            if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n            //Delete diagonial neighbours for the sake of cleaner maze\r\n            if(node[0] !== nodeIdx[0] && node[1] !== nodeIdx[1])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n        }\r\n        //Now the neighbours list only contains 'obstacle' nodes, that are neighbours with the chosen cell in x or y axis\r\n        //Iterate through the list\r\n        while(wallList.length > 0)\r\n        {\r\n            //Pick a random neighbour from the list\r\n            let wall = wallList[Math.floor(Math.random() * Math.floor(wallList.length))] \r\n            wall = getIndex(wall)\r\n            let visitedCounter = 0;\r\n            //Check if the chosen nodes doesn't have 2 explored neighbour nodes\r\n            let wallNeighbours = Object.keys(this.adj[wall.toString()])\r\n            for(let i = wallNeighbours.length-1; i >= 0; i--)\r\n            {\r\n                let nodeIdx = getIndex(wallNeighbours[i])\r\n                if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                    visitedCounter += 1;\r\n                }\r\n                //Delete diagonial neighbours for the sake of cleaner maze\r\n                if(wall[0] !== nodeIdx[0] && wall[1] !== nodeIdx[1])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            //Now wallNeighbours only contains the neighbours that are obstacles, aka walls \r\n            //Check for count of visited neighbours\r\n            if(visitedCounter <= 2)\r\n            {\r\n                this.visitedNodes[wall[1]][wall[0]] = true\r\n                for(let i = 0; i < wallNeighbours.length; i++)\r\n                {\r\n                    wallList.push(wallNeighbours[i])\r\n                }\r\n            }\r\n            wallList.splice(wallList.indexOf(wall.toString()), 1);\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport GridItem from './GridItem'\r\nimport Graph from '../PathfindingAlgorithms/Graph'\r\nimport Dijkstra from '../PathfindingAlgorithms/Dijkstra'\r\nimport Astar from '../PathfindingAlgorithms/Astar'\r\nimport Maze from '../PathfindingAlgorithms/Maze'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\nimport {compareNodes, getIndex, sleep} from '../PathfindingAlgorithms/Utility'\r\nimport './Grid.scss';\r\n\r\n\r\n//Current react layout is bad, we should've stored all this functionality in to a single component instead of two, Grid.jsx and PathfindingLayout.jsx\r\n//Now we need hacky methods to access child components states and call their functionality from parent component\r\nclass PathfindingLayout extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            gridRowCount: 35,                   \r\n            gridColCount: 72,\r\n\r\n            algorithm: undefined,\r\n            drawMode: undefined,\r\n            gridState: [],                   //Grid representation of node objects as 2d array\r\n            Graph: undefined,               //Graph representation of the grid (Adjacency list of the nodes and movement cost matrix)   \r\n\r\n            gridStartPos: undefined,\r\n            gridEndPos: undefined,\r\n            curGrid: undefined,             //Key of the current grid, for resetting the grid\r\n\r\n            isVisualized: false,\r\n            isAnimating: false,\r\n            animationSpeed: 50,                 //Animation speed in ms\r\n\r\n            showWeights: false,\r\n        }\r\n        this.handleAlgorithmModeChange = this.handleAlgorithmModeChange.bind(this);\r\n        this.handleDrawModeChange = this.handleDrawModeChange.bind(this);\r\n        this.handleResetClick = this.handleResetClick.bind(this);\r\n        this.handleSimulateClick = this.handleSimulateClick.bind(this);\r\n        this.generateMaze = this.generateMaze.bind(this);\r\n        this.animate = this.animate.bind(this);\r\n        this.AlgorithmTypes = Object.freeze({\r\n            Dijkstra,\r\n            Astar,\r\n        })\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.setState({algorithm: this.AlgorithmTypes.Dijkstra, drawMode: 1});\r\n        this.initGrid();\r\n    }\r\n\r\n    //Resets the whole grid\r\n    //TODO:: Instead of iterating through the whole grid, we could just store the nodes that need to be cleared into a state as an array, would increase performance by a quite a bit.\r\n    async handleResetClick(){\r\n        //Creating a new key for our grid component recreates the component from scratch. Since we only have one component using math.random should be fine\r\n        let newId = Math.random()\r\n        //this.cancelAnimation();\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        var oldGrid = [...this.state.gridState]\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                var oldNode = oldGrid[i][j][1]\r\n                oldNode.nodeType = 0;\r\n                oldNode.weight = 0;\r\n                var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                oldGrid[i][j][0] = oldGridItem\r\n            }\r\n        }\r\n        var newGraph = new Graph(this.state.gridState)\r\n        this.setState({curGrid: newId, gridState: oldGrid, Graph: newGraph, gridStartPos: undefined, gridEndPos: undefined})\r\n    }\r\n\r\n    handleSpeedSlider = (e) =>\r\n    {\r\n        this.setState({animationSpeed: e.target.value})\r\n    }\r\n\r\n    handleCheckboxChange = (e) => \r\n    {\r\n        this.setState({showWeights: e.target.value})\r\n    }\r\n\r\n    cancelAnimation()\r\n    {\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        let oldGrid = [...this.state.gridState]\r\n        let oldGraph = this.state.Graph\r\n        //This is atleast o(n^2) and is very costly way of cancelling the animation, maybe store the animated nodes to a heap instead of iterating through whole matrix\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                if(oldGrid[i][j][0].props.visited)\r\n                {\r\n                    var oldNode = oldGrid[i][j][1]\r\n                    oldNode.nodeType = 0;\r\n                    var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                    oldGrid[i][j][0] = oldGridItem\r\n                    oldGraph.updateNode(oldNode)\r\n                }\r\n            }\r\n        }\r\n        this.setState({gridState: oldGrid, Graph: oldGraph})\r\n        console.log(\"animation cancelled!\")\r\n    }\r\n\r\n    async handleSimulateClick(){\r\n        //Check if the grid in in animated state\r\n        if(this.state.isVisualized || this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n            await sleep(1);\r\n        }\r\n\r\n        if(this.state.gridState && this.state.gridStartPos && this.state.gridEndPos)\r\n        {\r\n            const start = this.state.gridStartPos.state.node.gridIndex\r\n            const goal = this.state.gridEndPos.state.node.gridIndex\r\n            //Call selected algorithm\r\n            //Create instance of the selected algorithm object\r\n            switch(this.state.algorithm)\r\n            {\r\n                case this.AlgorithmTypes.Dijkstra:\r\n                    var dijkstra = Dijkstra(this.state.Graph.adjacencyList, start, goal);\r\n                    this.animate(dijkstra[0], dijkstra[1])\r\n                    break;\r\n                case this.AlgorithmTypes.Astar:\r\n                    var astar = Astar(this.state.Graph.adjacencyList, start, goal)\r\n                    this.animate(astar[0], astar[1])\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.log(\"Grid was undefined\")\r\n        }\r\n    }\r\n\r\n    //Takes nodes to animate in array that's ordered\r\n    //nodesInOrder[0] is the node index and [1] is the weight of the node\r\n    async animate(nodesInOrder, shortestPath)\r\n    {\r\n        console.log(\"Animation started\");\r\n\r\n        await this.setState({isAnimating: true})\r\n\r\n        //Animate visitedNodes\r\n        let oldGrid = [...this.state.gridState];\r\n        for(const [nodeIdx, weight] of Object.entries(nodesInOrder))\r\n        {\r\n            await sleep(100 - this.state.animationSpeed);\r\n            if(!this.state.isAnimating)\r\n                return\r\n\r\n            //Get the index of the node, nodesInOrder is an array of strings instead of numbers (Because we're using js and not ts...)\r\n            var [x,y] = getIndex(nodeIdx)\r\n\r\n            //No need to animate the goal node\r\n            if(compareNodes([x,y], this.state.gridEndPos.state.node.gridIndex) || compareNodes([x,y], this.state.gridStartPos.state.node.gridIndex))\r\n                continue\r\n            var gridItem = oldGrid[y][x][0]\r\n\r\n            //Create inline style object depending on the weight value \r\n            let c = [0,191,255]     //rgb\r\n            c[0] += weight/3;\r\n            c[1] -= weight/3*2;\r\n            c[2] -= weight/3*2;\r\n\r\n            const _styleObj = {\r\n                'backgroundColor': 'rgb('+c[0]+','+c[1]+','+c[2]+')'\r\n            };\r\n\r\n            //Clone/Duplicate the gridItem component with new properties and overwrite the old one\r\n            let newGridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-visited', styleObj: _styleObj, weight: weight, showWeight: this.state.showWeights});\r\n            oldGrid[y][x][0] = newGridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        \r\n        //Animate shortest path in the end, no need to animate start or goal\r\n        for(let i = 1; i < shortestPath.length-1; i++)\r\n        {\r\n            await sleep(100 - this.state.animationSpeed)\r\n            if(!this.state.isAnimating)\r\n                return\r\n            let [x,y] = getIndex(shortestPath[i])\r\n            let gridItem = oldGrid[y][x][0]\r\n\r\n            gridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-shortestPath', styleObj: undefined});\r\n            oldGrid[y][x][0] = gridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        this.setState({gridState: oldGrid, isVisualized: true, isAnimated: false})\r\n    }\r\n\r\n    //Recursive maze generation\r\n    async generateMaze()\r\n    {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating || this.state.isVisualized)\r\n        {\r\n            //Since we don't need to clear the \"Visited nodes\" here, we can simply just reset the whole grid\r\n            this.handleResetClick();\r\n            await sleep(10);\r\n        }\r\n        //Generate maze from the current grid state\r\n        var maze = new Maze(this.state.Graph.adjacencyList);\r\n        await this.setState({isAnimating: true})\r\n        for(var x = 0; x < maze.visitedNodes.length; x++)\r\n        {\r\n            for(var y = 0; y < maze.visitedNodes[x].length; y++)\r\n            {\r\n                if(!this.state.isAnimating)\r\n                {\r\n                    this.setState({isVisualized: true})\r\n                    console.log(this.state.isVisualized)\r\n                    console.log(\"Cancelled\")\r\n                    await sleep(10);\r\n                    return\r\n                }\r\n                //If node is false, it's an obstacle\r\n                if(maze.visitedNodes[x][y] === false)\r\n                {\r\n                    let newGrid = this.state.gridState\r\n                    //Update the gridItem and the node in gridState\r\n                    await this.updateGridItem([y,x], newGrid[x][y][1], 3);\r\n                    //Sleep for a bit before next iteration\r\n                    await sleep(100 - this.state.animationSpeed);\r\n                }\r\n            }\r\n        }\r\n        this.setState({isAnimating: false, isVisualized: true})\r\n    }\r\n\r\n    handleAlgorithmModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"Dijkstra\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n            case \"Astar\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Astar})\r\n                break;\r\n            default:\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleDrawModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"start\":\r\n                this.setState({drawMode: 1})\r\n                break;\r\n            case \"end\":\r\n                this.setState({drawMode: 2})\r\n                break;\r\n            case \"obstacle\":\r\n                this.setState({drawMode: 3})\r\n                break;\r\n            default:\r\n                this.setState({drawMode: 1})\r\n                break;\r\n        }\r\n        //TODO:: Handle diff types as enums\r\n        console.log(\"this changed to \" + e.target.value);\r\n    }\r\n\r\n    gridWasClicked = (gridItem) => {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n        }\r\n        //Check if the clicked node was already the selected type\r\n        if(gridItem.state.node.nodeType === this.state.drawMode)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        let newNode = gridItem.state.node;\r\n        switch(this.state.drawMode)\r\n        {\r\n            //Draw mode is start\r\n            case 1:\r\n                if(this.state.gridStartPos)\r\n                {\r\n                    //Create temporary copy of the current start position node (Found by index from gridState array), so we don't mutate the active node directly\r\n                    let oldX = this.state.gridStartPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridStartPos.state.node.gridIndex[1]\r\n                    let oldStartNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldStartNode.nodeType = 0;\r\n                    \r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldStartNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new starting point\r\n                newNode.nodeType = 1\r\n                this.updateGridItem(newNode.gridIndex, newNode, 1);\r\n                //Update the grid starting position\r\n                this.setState({gridStartPos: gridItem})\r\n                break;\r\n            //Draw mode is end\r\n            case 2:\r\n                if(this.state.gridEndPos)\r\n                {\r\n                    //Create temporary copy of the current node\r\n                    let oldX = this.state.gridEndPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridEndPos.state.node.gridIndex[1]\r\n                    let oldEndNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldEndNode.nodeType = 0;\r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldEndNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new ending point\r\n                newNode.nodeType = 2\r\n                this.updateGridItem(newNode.gridIndex, newNode, 2);\r\n                //Update the grid starting position\r\n                this.setState({gridEndPos: gridItem})\r\n                break;\r\n            //Draw mode is obstacle\r\n            case 3:\r\n                newNode.nodeType = this.state.drawMode;\r\n                this.updateGridItem(newNode.gridIndex, newNode, 3);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    updateGridItem(idx, node, nodeType)\r\n    {\r\n        let oldGridState = [...this.state.gridState]\r\n        let _styleName = \"\" \r\n        switch(nodeType)\r\n        {\r\n            case 1:\r\n                _styleName = 'grid-item-start';\r\n                break;\r\n            case 2:\r\n                _styleName = 'grid-item-end';\r\n                break;\r\n            case 3:\r\n                _styleName = 'grid-item-obstacle';\r\n                break;\r\n            default:\r\n                _styleName = 'grid-item'\r\n                break;\r\n        }\r\n\r\n        let oldGridItem = React.cloneElement(oldGridState[idx[1]][idx[0]][0], {itemNode: node, styleName: _styleName});\r\n        oldGridState[idx[1]][idx[0]][0] = oldGridItem\r\n        node.nodeType = nodeType;       //For some reason the node's type isn't always the same as the parameter\r\n        oldGridState[idx[1]][idx[0]][1] = node\r\n\r\n        //Update the node in adjacency list aswell\r\n        let tmpGraph = this.state.Graph\r\n        tmpGraph.updateNode(node)\r\n        this.setState({gridState: oldGridState, Graph: tmpGraph})\r\n    }\r\n\r\n    pushElemsToGrid(elem){\r\n        let tmpArr = this.state.gridState;\r\n        tmpArr.push(elem);\r\n        this.setState({gridState: tmpArr});\r\n    }\r\n\r\n    initGrid()\r\n    {\r\n        //By calculating window.innerWidth/Heigth we could divide it by width/heigth of a GridItem and get the count to fill out the container\r\n        //Get the window dimensions\r\n        let width = window.innerWidth;\r\n        let height = window.innerHeight;\r\n        //14 px is the width and height of a GridItem component's rendered div\r\n        let colCount = Math.floor((width - 16) / 26);\r\n        let rowCount = Math.floor((height - 16) / 26);\r\n        //Store these just in a state just in case we'd want to resize the grid dynamically in the future\r\n        this.setState({gridColCount: colCount, gridRowCount: rowCount});\r\n\r\n        let counter = 0;\r\n        for(let row = 0; row < rowCount; row++)\r\n        {\r\n            let tmpRow = [];\r\n            for(let col = 0; col < colCount; col++)\r\n            {\r\n                //Create node object array which represents the grid's state (Used for data processing) and GridItem array which is used to render the grid\r\n                let node = new Node(col, row, 0);\r\n                var bool = false;\r\n                tmpRow.push([<GridItem key={counter} gridWasClicked={this.gridWasClicked} itemNode={node} styleName='grid-item' visited={bool}/>, node]);\r\n                \r\n                counter++;\r\n            }\r\n            this.pushElemsToGrid(tmpRow);\r\n        }\r\n        this.setState({Graph: new Graph(this.state.gridState)})\r\n    }\r\n\r\n    render(){\r\n        const grid = this.state.gridState\r\n        return(\r\n            <div className=\"layout-container\">\r\n                <nav className=\"layout-nav-bar\">\r\n                    <button className=\"layout-nav-button\" onClick={this.handleSimulateClick}>\r\n                        Simulate\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.generateMaze}>\r\n                        Generate maze\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.handleResetClick}>\r\n                        Reset\r\n                    </button>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Algorithm mode</label>\r\n                        <select name=\"algorithmMode\" id=\"algorithm_mode\" className=\"selector-dropdown\" onChange={this.handleAlgorithmModeChange}>\r\n                            <option value=\"Dijkstra\">Dijkstra</option>\r\n                            <option value=\"Astar\">A*</option>\r\n                        </select>\r\n                    </div>\r\n                    {/* Checkbox container for displaying weights, not ready for use yet */}\r\n                    {/* <div className=\"checkbox-container\">\r\n                        <label className=\"slider-description\">Show weights: </label>\r\n                        <input type=\"checkbox\" onChange={this.handleCheckboxChange}/>\r\n                    </div> */}\r\n                    <div className=\"slider-container\">\r\n                        <label className=\"slider-description\">Animation speed: {this.state.animationSpeed}</label>\r\n                        <input onChange={this.handleSpeedSlider} type=\"range\" className=\"animation-speed-slider\" min=\"1\" max=\"100\" value={this.state.animationSpeed}/>\r\n                    </div>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Drawing mode</label>\r\n                        <select name=\"drawingMode\" id=\"drawing_mode\" className=\"selector-dropdown\" onChange={this.handleDrawModeChange}>\r\n                            <option value=\"start\">Start location</option>\r\n                            <option value=\"end\">End location</option>\r\n                            <option value=\"obstacle\">Obstacle</option>\r\n                        </select>\r\n                    </div>\r\n                </nav>\r\n            <div>\r\n                <div key={this.state.curGrid} className=\"grid-container\">\r\n                    {grid.map((row, id) => <div key={id} className=\"grid-row\">{(row.map((item, id) => item[0]))}</div>)}\r\n                </div>\r\n            </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingLayout;","import React from 'react';\r\nimport PathfindingLayout from \"./PathfindingLayout\";\r\nimport './Layout.scss';\r\n\r\nclass Layout extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            currentLayout: <PathfindingLayout/>,\r\n        };\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div className=\"layout-wrapper\">\r\n                <PathfindingLayout/>\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default Layout;","import './App.css';\r\nimport Layout from './Components/Layout'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Layout/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}