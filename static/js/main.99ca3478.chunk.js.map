{"version":3,"sources":["PathfindingAlgorithms/Node.jsx","Components/GridItem.jsx","PathfindingAlgorithms/Utility.js","PathfindingAlgorithms/Graph.jsx","PathfindingAlgorithms/PriorityQueue.jsx","PathfindingAlgorithms/Dijkstra.js","PathfindingAlgorithms/Astar.js","PathfindingAlgorithms/Maze.js","Components/PathfindingLayout.jsx","Components/Layout.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","x","y","weight","this","gridIndex","nodeType","node","neighbours","push","idx","type","index","indexOf","splice","GridItem","props","cellWasHovered","e","preventDefault","buttons","gridWasClicked","document","selection","empty","window","getSelection","removeAllRanges","cellWasClicked","itemDiv","React","createRef","state","styleName","styleObj","showWeight","updateNode","bind","nodeObj","itemNode","setState","prevProps","isConstructed","visited","styleColor","undefined","className","style","onClick","onMouseOver","Component","getIndex","parseInt","split","compareNodes","node1","node2","sleep","ms","Promise","resolve","setTimeout","Graph","graph","adjacencyList","start","goal","initAdjList","newNode","removeEdge","length","Object","entries","generateNodeNeighbours","toString","nodeTuple","oldNeighbours","calcMovementCost","row","col","generateEdges","addEdge","PriorityQueue","queue","nodeIdx","priorityValue","qElem","doesContain","i","isEmpty","shift","Dijkstra","Adj","console","log","prioQ","shortestPath","toBeVisited","dist","parent","Infinity","queue_item","minNode","dequeue","neighbour","calcHeurestic","x1","y1","x2","y2","dx","Math","abs","dy","min","Astar","openSet","gScore","visitedNodes","nodesInOrder","next","includes","newCost","Maze","AdjList","adj","init","nodes","keys","maxRow","maxCol","tmpRow","j","generateMaze","nodeStr","wallList","wall","floor","random","visitedCounter","wallNeighbours","PathfindingLayout","handleSpeedSlider","animationSpeed","target","value","handleCheckboxChange","showWeights","gridItem","isAnimating","cancelAnimation","drawMode","gridStartPos","oldX","oldY","oldStartNode","gridState","updateGridItem","gridEndPos","oldEndNode","gridRowCount","gridColCount","algorithm","curGrid","isVisualized","handleAlgorithmModeChange","handleDrawModeChange","handleResetClick","handleSimulateClick","animate","AlgorithmTypes","freeze","width","innerWidth","colCount","rowCount","initGrid","newId","oldGrid","oldNode","oldGridItem","cloneElement","newGraph","oldGraph","dijkstra","astar","c","_styleObj","newGridItem","isAnimated","maze","newGrid","BFS","oldGridState","_styleName","tmpGraph","elem","tmpArr","counter","pushElemsToGrid","grid","name","id","onChange","max","map","item","Layout","currentLayout","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.99ca3478.chunk.js","sourcesContent":["export default class Node{\r\n    constructor(x,y, weight){\r\n        this.gridIndex = [x,y];\r\n        this.nodeType= 0;\r\n        this.weight = weight;\r\n    }\r\n\r\n    addNeighbour(node){\r\n        this.neighbours.push(node);\r\n    }\r\n\r\n    setGridIndex(idx)\r\n    {\r\n        this.gridIndex = idx;\r\n    }\r\n\r\n    getGridIndex()\r\n    {\r\n        return this.gridIndex;\r\n    }\r\n\r\n    setType(type)\r\n    {\r\n        this.nodeType = type;\r\n    }\r\n\r\n    getType()\r\n    {\r\n        return this.nodeType;\r\n    }\r\n\r\n    removeNeighbour(node){\r\n        const index = this.neighbours.indexOf(node);\r\n        if(index > -1)\r\n        {\r\n            this.neighbours.splice(index, 1);\r\n            return node;\r\n        }\r\n    }\r\n\r\n    getNeighbours()\r\n    {\r\n        return this.neighbours;\r\n    }\r\n}","import React from 'react';\r\nimport './Grid.scss'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\n\r\n//Just an object thats state is controlled by the grid\r\n//Used for animation and visualization only\r\nclass GridItem extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.itemDiv = React.createRef();\r\n        this.state = {\r\n            node: this.props.node,                  //Node object that's stored in this gridItem component. TODO:: Store all node objects in parent and then just pass their needed values as props to this component\r\n            styleName: this.props.styleName,        //Css style name what is changed with selecte drawing mode\r\n            styleObj: this.props.styleObj,          //Inline style object that's passed as a prop from parent, used to calculate the RGB color of the node from the weight value\r\n            showWeight: this.props.showWeight,      //This is a boolean for showing weights, has currently no use\r\n            weight: this.props.weight               //The actual weight value of the node after running desired algorithm\r\n        };\r\n        this.updateNode = this.updateNode.bind(this)\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        let nodeObj = this.props.itemNode\r\n        this.setState({node: nodeObj, styleName: this.props.styleName, styleObj: this.props.styleObj, showWeight: this.props.showWeight, weight: this.props.weight});\r\n    }\r\n\r\n    componentDidUpdate(prevProps)\r\n    {\r\n        if(this.props.showWeight != prevProps.showWeight)\r\n            this.setState({showWeight: this.props.showWeight})\r\n        if(this.props.styleName != prevProps.styleName)\r\n            this.setState({styleName: this.props.styleName})\r\n    }\r\n\r\n    componentWillUnmount()\r\n    {\r\n        //this.updateNode causing a memory leak since the notification method is still being ran ? \r\n        //TODO:: How to change style of each grid-item component from parent without lifting state up?\r\n        //Cannot lift state up to parent since there are so many grid-item components that need changing\r\n    }\r\n\r\n\r\n    updateNode(node)\r\n    {\r\n        this.setState({node: node});\r\n        switch(node.nodeType)\r\n        {\r\n            case 1:\r\n                this.setState({styleName: 'grid-item-start'});\r\n                break;\r\n            case 2:\r\n                this.setState({styleName: 'grid-item-end'});\r\n                break;\r\n            case 3:\r\n                this.setState({styleName: 'grid-item-obstacle'});\r\n                break;\r\n            default:\r\n                this.setState({styleName: this.props.styleName});\r\n                break;\r\n        }\r\n    }\r\n\r\n    //Handle cell hover over if mouse buttons are being pressed down, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasHovered = (e) => {\r\n        e.preventDefault();\r\n        var unFocus = function () {\r\n            if (document.selection) {\r\n              document.selection.empty()\r\n            } else {\r\n              window.getSelection().removeAllRanges()\r\n            }\r\n        } \r\n        //If the mouse buttons are being held down\r\n        if(e.buttons == 1 || e.buttons == 3)\r\n        {\r\n            \r\n            this.props.gridWasClicked(this);\r\n            unFocus();\r\n        }\r\n    }\r\n\r\n    //Handle cell click, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasClicked = (e) => {\r\n        e.preventDefault();\r\n        this.props.gridWasClicked(this);\r\n    }\r\n\r\n    render(){\r\n        //Variables that change depending on the passed props\r\n        let isConstructed = this.state.node ? true : false;\r\n        let styleName = this.props.visited ? this.props.styleName : this.state.styleName\r\n        let styleColor = this.props.visited ? this.props.styleObj : undefined\r\n        //let weightValue = this.props.showWeight ? this.state.weight : \"\"      //This can be used to display weights of the nodes\r\n        if(isConstructed)\r\n        {\r\n            return(\r\n                <div className={styleName} style={styleColor} onClick={this.cellWasClicked} onMouseOver={this.cellWasHovered}>    \r\n                </div> \r\n            ); \r\n        }\r\n        else{\r\n            return(<div/>)\r\n        }\r\n    }\r\n}\r\n\r\nexport default GridItem;","export function getIndex(node)\r\n{\r\n    //Since the grid index is stored a string in the node\r\n    //This quick hack function will always return the node's index value as integer\r\n    //check if nodeIdx is string or int array\r\n    if(typeof node != \"string\")\r\n        return node\r\n    let x = parseInt(node.split(',')[0])\r\n    let y = parseInt(node.split(',')[1])\r\n    return [x,y]\r\n}\r\n\r\nexport function compareNodes(node1, node2)\r\n{\r\n    if(node1[0] == node2[0] && node1[1] == node2[1])\r\n        return true\r\n    else\r\n        return false\r\n}\r\n\r\nexport function sleep(ms)\r\n{\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}","import {getIndex} from './Utility'\r\n\r\nexport default class Graph{\r\n    \r\n    constructor(graph)\r\n    {\r\n        this.graph = graph;\r\n        this.adjacencyList = {}\r\n        this.start = undefined;\r\n        this.goal = undefined;\r\n        //this.adjacencyList is adjacency list (key value paired dict type object) of nodes\r\n        /** For example\r\n        graph = {\r\n                node1: {node2 : 10, node3 : 14},\r\n                node2: ...,\r\n                }\r\n         */\r\n        this.initAdjList();\r\n    }\r\n\r\n    //Function for updating nodes after the graph is initialized\r\n    //E.g a node in graph changes to an obstacle, we remove edges between this node and it's neighbours, and delete the node after\r\n    updateNode(newNode)\r\n    {\r\n        //First update the node\r\n        this.graph[newNode.gridIndex[1]][newNode.gridIndex[0]][1] = newNode\r\n        //Check if the newly changed node was obstacle, if it was\r\n        //Remove the edges from this node to anywhere else\r\n        //We could also check if the node used to be an obstacle, then we would have no operations to perform\r\n        if(newNode.nodeType === 3)\r\n        {\r\n            for(var node in this.adjacencyList[newNode.gridIndex])\r\n            {\r\n                //Remove edges node->neighbour and neighbour->node\r\n                this.removeEdge(newNode.gridIndex, node)\r\n            }\r\n            \r\n            //Check diagonials if they're obstacles, if they're, remove edges between the non-obstacle nodes from x & y axis\r\n            var [x,y] = newNode.gridIndex\r\n            //x max = this.graph.length, x === row\r\n            //Check if col and row is out of bounds aswell\r\n            //Top right\r\n            if(x+1 < this.graph[0].length && y-1 > 0 && this.graph[y-1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x+1, y])\r\n            }\r\n            //Bottom right\r\n            if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x+1,y], [x, y+1])\r\n            }\r\n            //Bottom left\r\n            if(x-1 > 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x-1,y], [x, y+1])\r\n            }\r\n            //Top left\r\n            if(x-1 > 0 && y-1 > 0 && this.graph[y-1][x-1][1].nodeType === 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x-1, y])\r\n            }\r\n\r\n\r\n            //Remove the node from graph\r\n            //delete this.adjacencyList[newNode.gridIndex]\r\n            \r\n            //TODO:: WE COULD DO THIS TO SAVE MEMORY, BUT WE WOULD NEED TO CHANGE generateEdges() METHOD.\r\n            //E.g currently we check if this.graph[y+1][x+1].nodeType !=== 3, but when graph changes,\r\n            //that index won't be the the diagonial neighbour on the grid anymore, since the node is deleted\r\n            \r\n        }\r\n        //Check the other way around, if node used to be obstacle, add new neighbours to the node\r\n        else if(newNode.nodeType !== 3)\r\n        {\r\n            //Add the node to the graph\r\n            //Check if the node used to be an obstacle\r\n            if(Object.entries(this.adjacencyList[newNode.gridIndex]).length === 0)\r\n            {\r\n                this.adjacencyList[newNode.gridIndex] = {}\r\n                this.generateNodeNeighbours(newNode.gridIndex.toString())\r\n            }\r\n        }\r\n    }\r\n\r\n    calcMovementCost(node1, node2)\r\n    {\r\n        if(getIndex(node1)[0] === getIndex(node2)[0] || getIndex(node1)[1] === getIndex(node2)[1])\r\n            return 10\r\n        else\r\n            return 14\r\n    }\r\n\r\n    getWeight(node1, node2)\r\n    {\r\n        return this.adjacencyList[node1][node2];\r\n    }\r\n    \r\n    removeEdge(node1, node2)\r\n    {\r\n        node1 = node1.toString();\r\n        node2 = node2.toString();\r\n        delete this.adjacencyList[node1][node2]\r\n        delete this.adjacencyList[node2][node1]\r\n    }\r\n\r\n    //Function to add edges between two nodes\r\n    addEdge(nodeTuple){\r\n\r\n        let node1 = nodeTuple[0].toString()\r\n        let node2 = nodeTuple[1].toString()\r\n\r\n        //Check if there's already edge between nodes\r\n        for(var node in this.adjacencyList[node1])\r\n        {\r\n            if(node === node2)\r\n                return\r\n        }\r\n        let oldNeighbours;\r\n        \r\n        if(this.adjacencyList[node1] !== undefined)\r\n        {\r\n            //Get a dict of neighbours the node currently has\r\n            oldNeighbours = this.adjacencyList[node1]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node2] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node1] = oldNeighbours\r\n        }\r\n\r\n\r\n        if(this.adjacencyList[node2] !== undefined)\r\n        {\r\n            //Push node1 to node2's neighbours aswell\r\n            oldNeighbours = this.adjacencyList[node2]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node1] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node2] = oldNeighbours\r\n        }\r\n\r\n        return\r\n    }\r\n\r\n    //For creating the initial adjacency list from graph\r\n    initAdjList(){\r\n        //Iterate through graph node object array\r\n        for(var row = 0; row < this.graph.length; row++)\r\n        {\r\n            for(var col = 0; col < this.graph[row].length; col++)\r\n            {\r\n                //Node object's are stored in gridObject[1]\r\n                this.adjacencyList[this.graph[row][col][1].gridIndex] = {}\r\n            }\r\n        }\r\n        this.generateEdges();\r\n    }\r\n\r\n    generateNodeNeighbours(node)\r\n    {\r\n        let x = getIndex(node)[0]          //X max == this.graph[0]length 71\r\n        let y = getIndex(node)[1]          //Y max == this.graph.length 34\r\n\r\n        let node1 = [x,y]\r\n        var node2 = [0,0]\r\n        //If node is an obstacle, skip it\r\n        //TODO:: Consider just removing these from the graph ?\r\n        if(this.graph[y][x][1].nodeType === 3)\r\n            return\r\n        //this.graph has reversed x && y\r\n        //Origin of the graph is also in top left corner instead of bottom left corner which is the usual (TODO:: Change the point of origin?)\r\n        //Check edge cases and if the node is not obstacle for x && y axis\r\n        if(x-1 >= 0 && this.graph[y][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y];\r\n            this.addEdge([node1, node2])\r\n        }            \r\n        if(x+1 < this.graph[0].length && this.graph[y][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y-1 >= 0 && this.graph[y-1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y+1 < this.graph.length && this.graph[y+1][x][1].nodeType !== 3)\r\n        {\r\n            node2 = [x, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        //Diagonials\r\n        if(x-1 >= 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x-1 >= 0 && y-1 >= 0 && this.graph[y-1][x-1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x-1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y-1 >= 0 && this.graph[y-1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType !== 3)\r\n        {\r\n            node2 = [x+1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n    }\r\n\r\n    generateEdges(){\r\n        //Since we're using a grid what will always have neighbours in x-y and diagonial axis, we can just check whether those nodes are obstacles or not\r\n        //And add edges between those nodes\r\n        for(var node in this.adjacencyList)\r\n        {\r\n            this.generateNodeNeighbours(node)\r\n        }\r\n    }\r\n\r\n}","import Node from './Node'\r\nimport {getIndex} from './Utility'\r\n\r\nexport class PriorityQueue{\r\n    \r\n    constructor(props)\r\n    {\r\n        this.queue = []\r\n    }\r\n\r\n    queue_item(nodeIdx, priorityValue)\r\n    {\r\n        var [x,y] = getIndex(nodeIdx)\r\n        var qElem = new Node(x, y, priorityValue);\r\n        var doesContain = false;\r\n        \r\n        for(var i = 0; i < this.queue.length; i++)\r\n        {\r\n            if(this.queue[i].weight > qElem.weight)\r\n            {\r\n                this.queue.splice(i, 0, qElem)\r\n                doesContain = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!doesContain)\r\n            this.queue.push(qElem)\r\n    }\r\n\r\n    //We could hash the elements to get O(1) but we would still probably waste a lot of memory since the count of elements is high\r\n    //Consider using min heap ?\r\n    dequeue()\r\n    {\r\n        if(!this.isEmpty())\r\n        {\r\n            var node = this.queue.shift()\r\n            return node\r\n        }\r\n    }\r\n\r\n    isEmpty()\r\n    {\r\n        return this.queue.length > 0 ? false : true;\r\n    }\r\n}\r\n\r\nexport default PriorityQueue;","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes} from './Utility'\r\n\r\nexport default function Dijkstra(Adj, start, goal)\r\n{\r\n    if(!start)\r\n        console.log(\"start was not defined\")\r\n    if(!goal)\r\n        console.log(\"end was not defined\")\r\n    \r\n    var prioQ = new PriorityQueue();\r\n    var shortestPath = [] //Shortest path to goal node\r\n    var toBeVisited = {} //Closed set\r\n    var dist = []\r\n    var parent = []\r\n\r\n    for(var node in Adj)\r\n    {\r\n        dist[node] = Infinity\r\n        parent[node] = undefined\r\n    }\r\n\r\n    dist[start] = 0;\r\n    \r\n    for(var node in Adj)\r\n    {\r\n        prioQ.queue_item(node, dist[node])\r\n    }\r\n\r\n    while(!prioQ.isEmpty())\r\n    {\r\n        let qElem = prioQ.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [toBeVisited, shortestPath]\r\n        }\r\n        \r\n        //Iterate the neighbours and calculate their weights\r\n        for(var neighbour in Adj[minNode])\r\n        {\r\n            if(dist[neighbour] > dist[minNode] + Adj[minNode][neighbour])\r\n            {\r\n                dist[neighbour] = dist[minNode] + Adj[minNode][neighbour]\r\n                parent[neighbour] = minNode\r\n                //Update the priority of the node in priority queue\r\n                if(!toBeVisited[neighbour])\r\n                {\r\n                    prioQ.queue_item(neighbour, dist[neighbour])\r\n                    toBeVisited[neighbour] = dist[neighbour]\r\n                }\r\n            }\r\n        }\r\n            \r\n    }\r\n    \r\n    return toBeVisited, shortestPath\r\n}","import PriorityQueue from './PriorityQueue'\r\nimport {compareNodes, getIndex} from './Utility'\r\n\r\nfunction calcHeurestic(start, goal)\r\n{\r\n    var [x1,y1] = getIndex(start)\r\n    var [x2,y2] = getIndex(goal)\r\n    var dx = Math.abs(x1-x2)\r\n    var dy = Math.abs(y1-y2)\r\n    return (10 * (dx + dy) + (14 - 2 * 10) * Math.min(dx, dy))\r\n}\r\n\r\nexport default function Astar(Adj, start, goal)\r\n{\r\n    var openSet = new PriorityQueue();\r\n    var gScore = {}        //g score value for every node in graph\r\n    var parent = {}        //Predecessor of any given node in graph\r\n    var visitedNodes = []  //Closed set\r\n    var nodesInOrder = []  //For visualizer\r\n    var shortestPath = []  //The shortest path\r\n\r\n    //Initialize start node\r\n    openSet.queue_item(start, 0);\r\n    visitedNodes.push(start)\r\n    gScore[start] = 0;\r\n    parent[start] = undefined\r\n\r\n\r\n    while(!openSet.isEmpty())\r\n    {\r\n        let qElem = openSet.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        nodesInOrder[qElem.gridIndex] = gScore[qElem.gridIndex]\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [nodesInOrder, shortestPath]\r\n        }\r\n        \r\n        for(let neighbour in Adj[minNode])\r\n        {   \r\n            let next = getIndex(neighbour)\r\n            if(visitedNodes.includes(neighbour))\r\n                continue;\r\n            let newCost = gScore[minNode] + Adj[minNode][next]\r\n            if(!gScore[next] || newCost < gScore[next])\r\n            {                \r\n                parent[next] = minNode\r\n                //Calc the new fScore for the neighbour\r\n                gScore[next] = newCost\r\n                //Calculate f(n) (priority) for this new node\r\n                let weight = newCost + calcHeurestic(next, goal)\r\n                openSet.queue_item(next, weight)\r\n            }\r\n        }\r\n        visitedNodes.push(minNode.toString())\r\n    }\r\n\r\n    return;\r\n}","import {getIndex} from './Utility'\r\n\r\nexport default class Maze\r\n{\r\n    constructor(AdjList)\r\n    {\r\n        this.adj = AdjList\r\n        this.visitedNodes = []\r\n        this.init();\r\n    }\r\n\r\n    init()\r\n    {\r\n        //Initialize visited nodes 2d matrix\r\n        let nodes = Object.keys(this.adj)\r\n        var [maxRow,maxCol] = getIndex(nodes[nodes.length-1])\r\n        for(let i = 0; i <= maxCol; i++)\r\n        {\r\n            let tmpRow = []\r\n            for(let j = 0; j <= maxRow; j++)\r\n            {\r\n                tmpRow.push(false)\r\n            }\r\n            this.visitedNodes.push(tmpRow)\r\n        }\r\n        //Pick a node from the visited nodes, preferably from the top\r\n        this.generateMaze(nodes[0]);\r\n    }\r\n\r\n    generateMaze(nodeStr)\r\n    {\r\n        let node = getIndex(nodeStr);\r\n        //Mark the chosen node as visited\r\n        console.log(node)\r\n        this.visitedNodes[node[1]][node[0]] = true;\r\n        //Get the node's neighbours\r\n        let wallList = Object.keys(this.adj[nodeStr])\r\n        //Remove already visited neighbours, iterate in reverse since the indexes change when element is removed\r\n        for(let i = wallList.length-1; i >= 0; i--)\r\n        {\r\n            let nodeIdx = getIndex(wallList[i])\r\n            if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n            //Delete diagonial neighbours for the sake of cleaner maze\r\n            if(node[0] != nodeIdx[0] && node[1] != nodeIdx[1])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n        }\r\n        //Now the neighbours list only contains 'obstacle' nodes, that are neighbours with the chosen cell in x or y axis\r\n        //Iterate through the list\r\n        while(wallList.length > 0)\r\n        {\r\n            //Pick a random neighbour from the list\r\n            let wall = wallList[Math.floor(Math.random() * Math.floor(wallList.length))] \r\n            wall = getIndex(wall)\r\n            let visitedCounter = 0;\r\n            //Check if the chosen nodes doesn't have 2 explored neighbour nodes\r\n            let wallNeighbours = Object.keys(this.adj[wall.toString()])\r\n            for(let i = wallNeighbours.length-1; i >= 0; i--)\r\n            {\r\n                let nodeIdx = getIndex(wallNeighbours[i])\r\n                if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                    visitedCounter += 1;\r\n                }\r\n                //Delete diagonial neighbours for the sake of cleaner maze\r\n                if(wall[0] != nodeIdx[0] && wall[1] != nodeIdx[1])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            //Now wallNeighbours only contains the neighbours that are obstacles, aka walls \r\n            //Check for count of visited neighbours\r\n            if(visitedCounter <= 2)\r\n            {\r\n                this.visitedNodes[wall[1]][wall[0]] = true\r\n                for(let i = 0; i < wallNeighbours.length; i++)\r\n                {\r\n                    wallList.push(wallNeighbours[i])\r\n                }\r\n            }\r\n            wallList.splice(wallList.indexOf(wall.toString()), 1);\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport GridItem from './GridItem'\r\nimport Graph from '../PathfindingAlgorithms/Graph'\r\nimport Dijkstra from '../PathfindingAlgorithms/Dijkstra'\r\nimport Astar from '../PathfindingAlgorithms/Astar'\r\nimport Maze from '../PathfindingAlgorithms/Maze'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\nimport {compareNodes, getIndex, sleep} from '../PathfindingAlgorithms/Utility'\r\nimport './Grid.scss';\r\n\r\n\r\n//Current react layout is bad, we should've stored all this functionality in to a single component instead of two, Grid.jsx and PathfindingLayout.jsx\r\n//Now we need hacky methods to access child components states and call their functionality from parent component\r\nclass PathfindingLayout extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            gridRowCount: 35,                   \r\n            gridColCount: 72,\r\n\r\n            algorithm: undefined,\r\n            drawMode: undefined,\r\n            gridState: [],                   //Grid representation of node objects as 2d array\r\n            Graph: undefined,               //Graph representation of the grid (Adjacency list of the nodes and movement cost matrix)   \r\n\r\n            gridStartPos: undefined,\r\n            gridEndPos: undefined,\r\n            curGrid: undefined,             //Key of the current grid, for resetting the grid\r\n\r\n            isVisualized: false,\r\n            isAnimating: false,\r\n            animationSpeed: 50,                 //Animation speed in ms\r\n\r\n            showWeights: false,\r\n        }\r\n        this.handleAlgorithmModeChange = this.handleAlgorithmModeChange.bind(this);\r\n        this.handleDrawModeChange = this.handleDrawModeChange.bind(this);\r\n        this.handleResetClick = this.handleResetClick.bind(this);\r\n        this.handleSimulateClick = this.handleSimulateClick.bind(this);\r\n        this.generateMaze = this.generateMaze.bind(this);\r\n        this.animate = this.animate.bind(this);\r\n        this.AlgorithmTypes = Object.freeze({\r\n            Dijkstra,\r\n            Astar,\r\n        })\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.setState({algorithm: this.AlgorithmTypes.Dijkstra, drawMode: 1});\r\n        //Get the window dimensions\r\n        let width = window.innerWidth;\r\n        let height = window.innerWidth;\r\n        //14 px is the width and height of a GridItem component's rendered div\r\n        let colCount = Math.floor(width / 14);\r\n        let rowCount = Math.floor(width / 14);\r\n        this.setState({gridColCount: colCount, gridRowCount: rowCount});\r\n        this.initGrid();\r\n    }\r\n\r\n    //Resets the whole grid\r\n    //TODO:: Instead of iterating through the whole grid, we could just store the nodes that need to be cleared into a state as an array, would increase performance by a quite a bit.\r\n    async handleResetClick(){\r\n        //Creating a new key for our grid component recreates the component from scratch. Since we only have one component using math.random should be fine\r\n        let newId = Math.random()\r\n        //this.cancelAnimation();\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        var oldGrid = [...this.state.gridState]\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                var oldNode = oldGrid[i][j][1]\r\n                oldNode.nodeType = 0;\r\n                oldNode.weight = 0;\r\n                var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                oldGrid[i][j][0] = oldGridItem\r\n            }\r\n        }\r\n        var newGraph = new Graph(this.state.gridState)\r\n        this.setState({curGrid: newId, gridState: oldGrid, Graph: newGraph, gridStartPos: undefined, gridEndPos: undefined})\r\n    }\r\n\r\n    handleSpeedSlider = (e) =>\r\n    {\r\n        this.setState({animationSpeed: e.target.value})\r\n    }\r\n\r\n    handleCheckboxChange = (e) => \r\n    {\r\n        this.setState({showWeights: e.target.value})\r\n    }\r\n\r\n    cancelAnimation()\r\n    {\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        let oldGrid = [...this.state.gridState]\r\n        let oldGraph = this.state.Graph\r\n        //This is atleast o(n^2) and is very costly way of cancelling the animation, maybe store the animated nodes to a heap instead of iterating through whole matrix\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                if(oldGrid[i][j][0].props.visited)\r\n                {\r\n                    var oldNode = oldGrid[i][j][1]\r\n                    oldNode.nodeType = 0;\r\n                    var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                    oldGrid[i][j][0] = oldGridItem\r\n                    oldGraph.updateNode(oldNode)\r\n                }\r\n            }\r\n        }\r\n        this.setState({gridState: oldGrid, Graph: oldGraph})\r\n        console.log(\"animation cancelled!\")\r\n    }\r\n\r\n    async handleSimulateClick(){\r\n        //Check if the grid in in animated state\r\n        if(this.state.isVisualized || this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n            await sleep(1);\r\n        }\r\n\r\n        if(this.state.gridState && this.state.gridStartPos && this.state.gridEndPos)\r\n        {\r\n            const start = this.state.gridStartPos.state.node.gridIndex\r\n            const goal = this.state.gridEndPos.state.node.gridIndex\r\n            //Call selected algorithm\r\n            //Create instance of the selected algorithm object\r\n            switch(this.state.algorithm)\r\n            {\r\n                case this.AlgorithmTypes.Dijkstra:\r\n                    var dijkstra = Dijkstra(this.state.Graph.adjacencyList, start, goal);\r\n                    this.animate(dijkstra[0], dijkstra[1])\r\n                    break;\r\n                case this.AlgorithmTypes.Astar:\r\n                    var astar = Astar(this.state.Graph.adjacencyList, start, goal)\r\n                    this.animate(astar[0], astar[1])\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.log(\"Grid was undefined\")\r\n        }\r\n    }\r\n\r\n    //Takes nodes to animate in array that's ordered\r\n    //nodesInOrder[0] is the node index and [1] is the weight of the node\r\n    async animate(nodesInOrder, shortestPath)\r\n    {\r\n        console.log(\"Animation started\");\r\n\r\n        await this.setState({isAnimating: true})\r\n\r\n        //Animate visitedNodes\r\n        let oldGrid = [...this.state.gridState];\r\n        for(const [nodeIdx, weight] of Object.entries(nodesInOrder))\r\n        {\r\n            await sleep(100 - this.state.animationSpeed);\r\n            if(!this.state.isAnimating)\r\n                return\r\n\r\n            //Get the index of the node, nodesInOrder is an array of strings instead of numbers (Because we're using js and not ts...)\r\n            var [x,y] = getIndex(nodeIdx)\r\n\r\n            //No need to animate the goal node\r\n            if(compareNodes([x,y], this.state.gridEndPos.state.node.gridIndex) || compareNodes([x,y], this.state.gridStartPos.state.node.gridIndex))\r\n                continue\r\n            var gridItem = oldGrid[y][x][0]\r\n\r\n            //Create inline style object depending on the weight value \r\n            let c = [0,191,255]     //rgb\r\n            c[0] += weight/3;\r\n            c[1] -= weight/3*2;\r\n            c[2] -= weight/3*2;\r\n\r\n            const _styleObj = {\r\n                'background-color': 'rgb('+c[0]+','+c[1]+','+c[2]+')'\r\n            };\r\n\r\n            //Clone/Duplicate the gridItem component with new properties and overwrite the old one\r\n            let newGridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-visited', styleObj: _styleObj, weight: weight, showWeight: this.state.showWeights});\r\n            oldGrid[y][x][0] = newGridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        \r\n        //Animate shortest path in the end, no need to animate start or goal\r\n        for(let i = 1; i < shortestPath.length-1; i++)\r\n        {\r\n            await sleep(100 - this.state.animationSpeed)\r\n            if(!this.state.isAnimating)\r\n                return\r\n            let [x,y] = getIndex(shortestPath[i])\r\n            let gridItem = oldGrid[y][x][0]\r\n\r\n            gridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-shortestPath', styleObj: undefined});\r\n            oldGrid[y][x][0] = gridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        this.setState({gridState: oldGrid, isVisualized: true, isAnimated: false})\r\n    }\r\n\r\n    //Recursive maze generation\r\n    async generateMaze()\r\n    {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating || this.state.isVisualized)\r\n        {\r\n            //Since we don't need to clear the \"Visited nodes\" here, we can simply just reset the whole grid\r\n            this.handleResetClick();\r\n            await sleep(10);\r\n        }\r\n        //Generate maze from the current grid state\r\n        var maze = new Maze(this.state.Graph.adjacencyList);\r\n        await this.setState({isAnimating: true})\r\n        for(var x = 0; x < maze.visitedNodes.length; x++)\r\n        {\r\n            for(var y = 0; y < maze.visitedNodes[x].length; y++)\r\n            {\r\n                if(!this.state.isAnimating)\r\n                {\r\n                    this.setState({isVisualized: true})\r\n                    console.log(this.state.isVisualized)\r\n                    console.log(\"Cancelled\")\r\n                    await sleep(10);\r\n                    return\r\n                }\r\n                //If node is false, it's an obstacle\r\n                if(maze.visitedNodes[x][y] === false)\r\n                {\r\n                    let newGrid = this.state.gridState\r\n                    //Update the gridItem and the node in gridState\r\n                    await this.updateGridItem([y,x], newGrid[x][y][1], 3);\r\n                    //Sleep for a bit before next iteration\r\n                    await sleep(100 - this.state.animationSpeed);\r\n                }\r\n            }\r\n        }\r\n        this.setState({isAnimating: false, isVisualized: true})\r\n    }\r\n\r\n    handleAlgorithmModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"Dijkstra\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n            case \"Astar\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Astar})\r\n                break;\r\n            case \"BFS\":\r\n                this.setState({algorithm: this.AlgorithmTypes.BFS})\r\n                break;\r\n            default:\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleDrawModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"start\":\r\n                this.setState({drawMode: 1})\r\n                break;\r\n            case \"end\":\r\n                this.setState({drawMode: 2})\r\n                break;\r\n            case \"obstacle\":\r\n                this.setState({drawMode: 3})\r\n                break;\r\n            default:\r\n                this.setState({drawMode: 1})\r\n                break;\r\n        }\r\n        //TODO:: Handle diff types as enums\r\n        console.log(\"this changed to \" + e.target.value);\r\n    }\r\n\r\n    gridWasClicked = (gridItem) => {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n        }\r\n        //Check if the clicked node was already the selected type\r\n        if(gridItem.state.node.nodeType === this.state.drawMode)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        let newNode = gridItem.state.node;\r\n        switch(this.state.drawMode)\r\n        {\r\n            //Draw mode is start\r\n            case 1:\r\n                if(this.state.gridStartPos)\r\n                {\r\n                    //Create temporary copy of the current start position node (Found by index from gridState array), so we don't mutate the active node directly\r\n                    let oldX = this.state.gridStartPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridStartPos.state.node.gridIndex[1]\r\n                    let oldStartNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldStartNode.nodeType = 0;\r\n                    \r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldStartNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new starting point\r\n                newNode.nodeType = 1\r\n                this.updateGridItem(newNode.gridIndex, newNode, 1);\r\n                //Update the grid starting position\r\n                this.setState({gridStartPos: gridItem})\r\n                break;\r\n            //Draw mode is end\r\n            case 2:\r\n                if(this.state.gridEndPos)\r\n                {\r\n                    //Create temporary copy of the current node\r\n                    let oldX = this.state.gridEndPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridEndPos.state.node.gridIndex[1]\r\n                    let oldEndNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldEndNode.nodeType = 0;\r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldEndNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new ending point\r\n                newNode.nodeType = 2\r\n                this.updateGridItem(newNode.gridIndex, newNode, 2);\r\n                //Update the grid starting position\r\n                this.setState({gridEndPos: gridItem})\r\n                break;\r\n            //Draw mode is obstacle\r\n            case 3:\r\n                newNode.nodeType = this.state.drawMode;\r\n                this.updateGridItem(newNode.gridIndex, newNode, 3);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    updateGridItem(idx, node, nodeType)\r\n    {\r\n        let oldGridState = [...this.state.gridState]\r\n        let _styleName = \"\" \r\n        switch(nodeType)\r\n        {\r\n            case 1:\r\n                _styleName = 'grid-item-start';\r\n                break;\r\n            case 2:\r\n                _styleName = 'grid-item-end';\r\n                break;\r\n            case 3:\r\n                _styleName = 'grid-item-obstacle';\r\n                break;\r\n            default:\r\n                _styleName = 'grid-item'\r\n                break;\r\n        }\r\n\r\n        let oldGridItem = React.cloneElement(oldGridState[idx[1]][idx[0]][0], {itemNode: node, styleName: _styleName});\r\n        oldGridState[idx[1]][idx[0]][0] = oldGridItem\r\n        node.nodeType = nodeType;       //For some reason the node's type isn't always the same as the parameter\r\n        oldGridState[idx[1]][idx[0]][1] = node\r\n\r\n        //Update the node in adjacency list aswell\r\n        let tmpGraph = this.state.Graph\r\n        tmpGraph.updateNode(node)\r\n        this.setState({gridState: oldGridState, Graph: tmpGraph})\r\n    }\r\n\r\n    pushElemsToGrid(elem){\r\n        let tmpArr = this.state.gridState;\r\n        tmpArr.push(elem);\r\n        this.setState({gridState: tmpArr});\r\n    }\r\n\r\n    initGrid()\r\n    {\r\n        //By calculating window.innerWidth/Heigth we could divide it by width/heigth of a GridItem and get the count to fill out the container\r\n        let counter = 0;\r\n        for(let row = 0; row < this.state.gridRowCount; row++)\r\n        {\r\n            let tmpRow = [];\r\n            for(let col = 0; col < this.state.gridColCount; col++)\r\n            {\r\n                //Create node object array which represents the grid's state (Used for data processing) and GridItem array which is used to render the grid\r\n                let node = new Node(col, row, 0);\r\n                var bool = false;\r\n                tmpRow.push([<GridItem key={counter} gridWasClicked={this.gridWasClicked} itemNode={node} styleName='grid-item' visited={bool}/>, node]);\r\n                \r\n                counter++;\r\n            }\r\n            this.pushElemsToGrid(tmpRow);\r\n        }\r\n        this.setState({Graph: new Graph(this.state.gridState)})\r\n    }\r\n\r\n    render(){\r\n        const grid = this.state.gridState ? this.state.gridState : [[1]]\r\n        return(\r\n            <div className=\"layout-container\">\r\n                <nav className=\"layout-nav-bar\">\r\n                    <button className=\"layout-nav-button\" onClick={this.handleSimulateClick}>\r\n                        Simulate\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.generateMaze}>\r\n                        Generate maze\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.handleResetClick}>\r\n                        Reset\r\n                    </button>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Algorithm mode</label>\r\n                        <select name=\"algorithmMode\" id=\"algorithm_mode\" className=\"selector-dropdown\" onChange={this.handleAlgorithmModeChange}>\r\n                            <option value=\"Dijkstra\">Dijkstra</option>\r\n                            <option value=\"Astar\">A*</option>\r\n                        </select>\r\n                    </div>\r\n                    {/* Checkbox container for displaying weights, not ready for use yet */}\r\n                    {/* <div className=\"checkbox-container\">\r\n                        <label className=\"slider-description\">Show weights: </label>\r\n                        <input type=\"checkbox\" onChange={this.handleCheckboxChange}/>\r\n                    </div> */}\r\n                    <div className=\"slider-container\">\r\n                        <label className=\"slider-description\">Animation speed: {this.state.animationSpeed}</label>\r\n                        <input onChange={this.handleSpeedSlider} type=\"range\" className=\"animation-speed-slider\" min=\"1\" max=\"100\" value={this.state.animationSpeed}/>\r\n                    </div>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Drawing mode</label>\r\n                        <select name=\"drawingMode\" id=\"drawing_mode\" className=\"selector-dropdown\" onChange={this.handleDrawModeChange}>\r\n                            <option value=\"start\">Start location</option>\r\n                            <option value=\"end\">End location</option>\r\n                            <option value=\"obstacle\">Obstacle</option>\r\n                        </select>\r\n                    </div>\r\n                </nav>\r\n            <div>\r\n                <div key={this.state.curGrid} className=\"grid-container\">\r\n                    {grid.map((row, id) => <div key={id} className=\"grid-row\">{(row.map((item, id) => item[0]))}</div>)}\r\n                </div>\r\n            </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingLayout;","import React from 'react';\r\nimport PathfindingLayout from \"./PathfindingLayout\";\r\nimport './Layout.scss';\r\n\r\nclass Layout extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            currentLayout: <PathfindingLayout/>,\r\n        };\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div className=\"layout-wrapper\">\r\n                {this.state.currentLayout}\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default Layout;","import './App.css';\r\nimport Layout from './Components/Layout'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Layout/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}