{"version":3,"sources":["PathfindingAlgorithms/Node.jsx","Components/GridItem.jsx","PathfindingAlgorithms/Utility.js","PathfindingAlgorithms/Graph.jsx","PathfindingAlgorithms/PriorityQueue.jsx","PathfindingAlgorithms/Dijkstra.js","PathfindingAlgorithms/Astar.js","PathfindingAlgorithms/BFS.js","PathfindingAlgorithms/Maze.js","Components/PathfindingLayout.jsx","Components/Layout.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","x","y","weight","this","gridIndex","nodeType","node","neighbours","push","idx","type","index","indexOf","splice","GridItem","props","cellWasHovered","e","preventDefault","buttons","gridWasClicked","document","selection","empty","window","getSelection","removeAllRanges","cellWasClicked","itemDiv","React","createRef","state","styleName","styleObj","showWeight","updateNode","bind","nodeObj","itemNode","setState","prevProps","isConstructed","visited","styleColor","undefined","className","style","onClick","onMouseOver","Component","getIndex","parseInt","split","compareNodes","node1","node2","sleep","ms","Promise","resolve","setTimeout","Graph","graph","adjacencyList","start","goal","initAdjList","newNode","removeEdge","length","Object","entries","generateNodeNeighbours","toString","nodeTuple","oldNeighbours","calcMovementCost","row","col","generateEdges","addEdge","PriorityQueue","queue","nodeIdx","priorityValue","qElem","doesContain","i","isEmpty","shift","Dijkstra","Adj","console","log","prioQ","shortestPath","toBeVisited","dist","parent","Infinity","queue_item","minNode","dequeue","neighbour","calcHeurestic","x1","y1","x2","y2","dx","Math","abs","dy","min","Astar","openSet","gScore","visitedNodes","nodesInOrder","next","includes","newCost","BFS","end","Maze","AdjList","adj","init","nodes","keys","maxRow","maxCol","tmpRow","j","generateMaze","nodeStr","wallList","wall","floor","random","visitedCounter","wallNeighbours","PathfindingLayout","handleSpeedSlider","animationSpeed","target","value","handleCheckboxChange","showWeights","gridItem","isVisualized","isAnimating","cancelAnimation","drawMode","gridStartPos","oldX","oldY","oldStartNode","gridState","updateGridItem","gridEndPos","oldEndNode","gridRowCount","gridColCount","algorithm","curGrid","handleAlgorithmModeChange","handleDrawModeChange","handleResetClick","handleSimulateClick","animate","AlgorithmTypes","freeze","initGrid","newId","oldGrid","oldNode","oldGridItem","cloneElement","newGraph","oldGraph","dijkstra","astar","c","_styleObj","newGridItem","isAnimated","maze","newGrid","oldGridState","_styleName","tmpGraph","elem","tmpArr","counter","pushElemsToGrid","grid","name","id","onChange","max","map","item","Layout","currentLayout","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a4f289e9.chunk.js","sourcesContent":["export class Node{\r\n    constructor(x,y, weight){\r\n        this.gridIndex = [x,y];\r\n        this.nodeType= 0;\r\n        this.weight = weight;\r\n    }\r\n\r\n    addNeighbour(node){\r\n        this.neighbours.push(node);\r\n    }\r\n\r\n    setGridIndex(idx)\r\n    {\r\n        this.gridIndex = idx;\r\n    }\r\n\r\n    getGridIndex()\r\n    {\r\n        return this.gridIndex;\r\n    }\r\n\r\n    setType(type)\r\n    {\r\n        this.nodeType = type;\r\n    }\r\n\r\n    getType()\r\n    {\r\n        return this.nodeType;\r\n    }\r\n\r\n    removeNeighbour(node){\r\n        const index = this.neighbours.indexOf(node);\r\n        if(index > -1)\r\n        {\r\n            this.neighbours.splice(index, 1);\r\n            return node;\r\n        }\r\n    }\r\n\r\n    getNeighbours()\r\n    {\r\n        return this.neighbours;\r\n    }\r\n}\r\n\r\nexport default Node;","import React from 'react';\r\nimport './Grid.scss'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\n\r\n//Just an object thats state is controlled by the grid\r\n//Used for animation and visualization only\r\nclass GridItem extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.itemDiv = React.createRef();\r\n        this.state = {\r\n            node: this.props.node,                  //Node object that's stored in this gridItem component. TODO:: Store all node objects in parent and then just pass their needed values as props to this component\r\n            styleName: this.props.styleName,        //Css style name what is changed with selecte drawing mode\r\n            styleObj: this.props.styleObj,          //Inline style object that's passed as a prop from parent, used to calculate the RGB color of the node from the weight value\r\n            showWeight: this.props.showWeight,      //This is a boolean for showing weights, has currently no use\r\n            weight: this.props.weight               //The actual weight value of the node after running desired algorithm\r\n        };\r\n        this.updateNode = this.updateNode.bind(this)\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        let nodeObj = this.props.itemNode\r\n        this.setState({node: nodeObj, styleName: this.props.styleName, styleObj: this.props.styleObj, showWeight: this.props.showWeight, weight: this.props.weight});\r\n    }\r\n\r\n    componentDidUpdate(prevProps)\r\n    {\r\n        if(this.props.showWeight != prevProps.showWeight)\r\n            this.setState({showWeight: this.props.showWeight})\r\n        if(this.props.styleName != prevProps.styleName)\r\n            this.setState({styleName: this.props.styleName})\r\n    }\r\n\r\n    componentWillUnmount()\r\n    {\r\n        //this.updateNode causing a memory leak since the notification method is still being ran ? \r\n        //TODO:: How to change style of each grid-item component from parent without lifting state up?\r\n        //Cannot lift state up to parent since there are so many grid-item components that need changing\r\n    }\r\n\r\n\r\n    updateNode(node)\r\n    {\r\n        this.setState({node: node});\r\n        switch(node.nodeType)\r\n        {\r\n            case 1:\r\n                this.setState({styleName: 'grid-item-start'});\r\n                break;\r\n            case 2:\r\n                this.setState({styleName: 'grid-item-end'});\r\n                break;\r\n            case 3:\r\n                this.setState({styleName: 'grid-item-obstacle'});\r\n                break;\r\n            default:\r\n                this.setState({styleName: this.props.styleName});\r\n                break;\r\n        }\r\n    }\r\n\r\n    //Handle cell hover over if mouse buttons are being pressed down, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasHovered = (e) => {\r\n        e.preventDefault();\r\n        var unFocus = function () {\r\n            if (document.selection) {\r\n              document.selection.empty()\r\n            } else {\r\n              window.getSelection().removeAllRanges()\r\n            }\r\n        } \r\n        //If the mouse buttons are being held down\r\n        if(e.buttons == 1 || e.buttons == 3)\r\n        {\r\n            \r\n            this.props.gridWasClicked(this);\r\n            unFocus();\r\n        }\r\n    }\r\n\r\n    //Handle cell click, send notification of clicked cell to parent, where the input is being handled\r\n    cellWasClicked = (e) => {\r\n        e.preventDefault();\r\n        this.props.gridWasClicked(this);\r\n    }\r\n\r\n    render(){\r\n        //Variables that change depending on the passed props\r\n        let isConstructed = this.state.node ? true : false;\r\n        let styleName = this.props.visited ? this.props.styleName : this.state.styleName\r\n        let styleColor = this.props.visited ? this.props.styleObj : undefined\r\n        //let weightValue = this.props.showWeight ? this.state.weight : \"\"      //This can be used to display weights of the nodes\r\n        if(isConstructed)\r\n        {\r\n            return(\r\n                <div className={styleName} style={styleColor} onClick={this.cellWasClicked} onMouseOver={this.cellWasHovered}>    \r\n                </div> \r\n            ); \r\n        }\r\n        else{\r\n            return(<div/>)\r\n        }\r\n    }\r\n}\r\n\r\nexport default GridItem;","export function getIndex(node)\r\n{\r\n    //Since the grid index is stored a string in the node\r\n    //This quick hack function will always return the node's index value as integer\r\n    //check if nodeIdx is string or int array\r\n    if(typeof node != \"string\")\r\n        return node\r\n    let x = parseInt(node.split(',')[0])\r\n    let y = parseInt(node.split(',')[1])\r\n    return [x,y]\r\n}\r\n\r\nexport function compareNodes(node1, node2)\r\n{\r\n    if(node1[0] == node2[0] && node1[1] == node2[1])\r\n        return true\r\n    else\r\n        return false\r\n}\r\n\r\nexport function sleep(ms)\r\n{\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}","import {Node} from './Node'\r\nimport {getIndex} from './Utility'\r\n\r\nexport class Graph{\r\n    \r\n    constructor(graph)\r\n    {\r\n        this.graph = graph;\r\n        this.adjacencyList = {}\r\n        this.start = undefined;\r\n        this.goal = undefined;\r\n        //this.adjacencyList is adjacency list (key value paired dict type object) of nodes\r\n        /** For example\r\n        graph = {\r\n                node1: {node2 : 10, node3 : 14},\r\n                node2: ...,\r\n                }\r\n         */\r\n        this.initAdjList();\r\n    }\r\n\r\n    //Function for updating nodes after the graph is initialized\r\n    //E.g a node in graph changes to an obstacle, we remove edges between this node and it's neighbours, and delete the node after\r\n    updateNode(newNode)\r\n    {\r\n        //First update the node\r\n        this.graph[newNode.gridIndex[1]][newNode.gridIndex[0]][1] = newNode\r\n        //Check if the newly changed node was obstacle, if it was\r\n        //Remove the edges from this node to anywhere else\r\n        //We could also check if the node used to be an obstacle, then we would have no operations to perform\r\n        if(newNode.nodeType == 3)\r\n        {\r\n            for(var node in this.adjacencyList[newNode.gridIndex])\r\n            {\r\n                //Remove edges node->neighbour and neighbour->node\r\n                this.removeEdge(newNode.gridIndex, node)\r\n            }\r\n            \r\n            //Check diagonials if they're obstacles, if they're, remove edges between the non-obstacle nodes from x & y axis\r\n            var [x,y] = newNode.gridIndex\r\n            //x max = this.graph.length, x == row\r\n            //Check if col and row is out of bounds aswell\r\n            //Top right\r\n            if(x+1 < this.graph[0].length && y-1 > 0 && this.graph[y-1][x+1][1].nodeType == 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x+1, y])\r\n            }\r\n            //Bottom right\r\n            if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType == 3)\r\n            {\r\n                this.removeEdge([x+1,y], [x, y+1])\r\n            }\r\n            //Bottom left\r\n            if(x-1 > 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType == 3)\r\n            {\r\n                this.removeEdge([x-1,y], [x, y+1])\r\n            }\r\n            //Top left\r\n            if(x-1 > 0 && y-1 > 0 && this.graph[y-1][x-1][1].nodeType == 3)\r\n            {\r\n                this.removeEdge([x,y-1], [x-1, y])\r\n            }\r\n\r\n\r\n            //Remove the node from graph\r\n            //delete this.adjacencyList[newNode.gridIndex]\r\n            \r\n            //TODO:: WE COULD DO THIS TO SAVE MEMORY, BUT WE WOULD NEED TO CHANGE generateEdges() METHOD.\r\n            //E.g currently we check if this.graph[y+1][x+1].nodeType != 3, but when graph changes,\r\n            //that index won't be the the diagonial neighbour on the grid anymore, since the node is deleted\r\n            \r\n        }\r\n        //Check the other way around, if node used to be obstacle, add new neighbours to the node\r\n        else if(newNode.nodeType != 3)\r\n        {\r\n            //Add the node to the graph\r\n            //Check if the node used to be an obstacle\r\n            if(Object.entries(this.adjacencyList[newNode.gridIndex]).length == 0)\r\n            {\r\n                this.adjacencyList[newNode.gridIndex] = {}\r\n                this.generateNodeNeighbours(newNode.gridIndex.toString())\r\n            }\r\n        }\r\n    }\r\n\r\n    calcMovementCost(node1, node2)\r\n    {\r\n        if(getIndex(node1)[0] == getIndex(node2)[0] || getIndex(node1)[1] == getIndex(node2)[1])\r\n            return 10\r\n        else\r\n            return 14\r\n    }\r\n\r\n    getWeight(node1, node2)\r\n    {\r\n        return this.adjacencyList[node1][node2];\r\n    }\r\n    \r\n    removeEdge(node1, node2)\r\n    {\r\n        node1 = node1.toString();\r\n        node2 = node2.toString();\r\n        delete this.adjacencyList[node1][node2]\r\n        delete this.adjacencyList[node2][node1]\r\n    }\r\n\r\n    //Function to add edges between two nodes\r\n    addEdge(nodeTuple){\r\n\r\n        let node1 = nodeTuple[0].toString()\r\n        let node2 = nodeTuple[1].toString()\r\n\r\n        //Check if there's already edge between nodes\r\n        for(var node in this.adjacencyList[node1])\r\n        {\r\n            if(node == node2)\r\n                return\r\n        }\r\n        let oldNeighbours;\r\n        \r\n        if(this.adjacencyList[node1] != undefined)\r\n        {\r\n            //Get a dict of neighbours the node currently has\r\n            oldNeighbours = this.adjacencyList[node1]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node2] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node1] = oldNeighbours\r\n        }\r\n\r\n\r\n        if(this.adjacencyList[node2] != undefined)\r\n        {\r\n            //Push node1 to node2's neighbours aswell\r\n            oldNeighbours = this.adjacencyList[node2]\r\n            //Add the new neighbour and calculate the weight\r\n            oldNeighbours[node1] = this.calcMovementCost(node1, node2)\r\n            //Push the new list of neighbours to the dictionary\r\n            this.adjacencyList[node2] = oldNeighbours\r\n        }\r\n\r\n        return\r\n    }\r\n\r\n    //For creating the initial adjacency list from graph\r\n    initAdjList(){\r\n        //Iterate through graph node object array\r\n        for(var row = 0; row < this.graph.length; row++)\r\n        {\r\n            for(var col = 0; col < this.graph[row].length; col++)\r\n            {\r\n                //Node object's are stored in gridObject[1]\r\n                this.adjacencyList[this.graph[row][col][1].gridIndex] = {}\r\n            }\r\n        }\r\n        this.generateEdges();\r\n    }\r\n\r\n    generateNodeNeighbours(node)\r\n    {\r\n        let x = getIndex(node)[0]          //X max == this.graph[0]length 71\r\n        let y = getIndex(node)[1]          //Y max == this.graph.length 34\r\n\r\n        let node1 = [x,y]\r\n        var node2 = [0,0]\r\n        //If node is an obstacle, skip it\r\n        //TODO:: Consider just removing these from the graph ?\r\n        if(this.graph[y][x][1].nodeType == 3)\r\n            return\r\n        //this.graph has reversed x && y\r\n        //Origin of the graph is also in top left corner instead of bottom left corner which is the usual (TODO:: Change the point of origin?)\r\n        //Check edge cases and if the node is not obstacle for x && y axis\r\n        if(x-1 >= 0 && this.graph[y][x-1][1].nodeType != 3)\r\n        {\r\n            node2 = [x-1, y];\r\n            this.addEdge([node1, node2])\r\n        }            \r\n        if(x+1 < this.graph[0].length && this.graph[y][x+1][1].nodeType != 3)\r\n        {\r\n            node2 = [x+1, y]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y-1 >= 0 && this.graph[y-1][x][1].nodeType != 3)\r\n        {\r\n            node2 = [x, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(y+1 < this.graph.length && this.graph[y+1][x][1].nodeType != 3)\r\n        {\r\n            node2 = [x, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        //Diagonials\r\n        if(x-1 >= 0 && y+1 < this.graph.length && this.graph[y+1][x-1][1].nodeType != 3)\r\n        {\r\n            node2 = [x-1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x-1 >= 0 && y-1 >= 0 && this.graph[y-1][x-1][1].nodeType != 3)\r\n        {\r\n            node2 = [x-1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y-1 >= 0 && this.graph[y-1][x+1][1].nodeType != 3)\r\n        {\r\n            node2 = [x+1, y-1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n        if(x+1 < this.graph[0].length && y+1 < this.graph.length && this.graph[y+1][x+1][1].nodeType != 3)\r\n        {\r\n            node2 = [x+1, y+1]\r\n            this.addEdge([node1, node2])\r\n        }\r\n    }\r\n\r\n    generateEdges(){\r\n        //Since we're using a grid what will always have neighbours in x-y and diagonial axis, we can just check whether those nodes are obstacles or not\r\n        //And add edges between those nodes\r\n        for(var node in this.adjacencyList)\r\n        {\r\n            this.generateNodeNeighbours(node)\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport default Graph;","import {Node} from './Node'\r\nimport {getIndex} from './Utility'\r\n\r\nexport class PriorityQueue{\r\n    \r\n    constructor(props)\r\n    {\r\n        this.queue = []\r\n    }\r\n\r\n    queue_item(nodeIdx, priorityValue)\r\n    {\r\n        var [x,y] = getIndex(nodeIdx)\r\n        var qElem = new Node(x, y, priorityValue);\r\n        var doesContain = false;\r\n        \r\n        for(var i = 0; i < this.queue.length; i++)\r\n        {\r\n            if(this.queue[i].weight > qElem.weight)\r\n            {\r\n                this.queue.splice(i, 0, qElem)\r\n                doesContain = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!doesContain)\r\n            this.queue.push(qElem)\r\n    }\r\n\r\n    //We could hash the elements to get O(1) but we would still probably waste a lot of memory since the count of elements is high\r\n    //Consider using min heap ?\r\n    dequeue()\r\n    {\r\n        if(!this.isEmpty())\r\n        {\r\n            var node = this.queue.shift()\r\n            return node\r\n        }\r\n    }\r\n\r\n    isEmpty()\r\n    {\r\n        return this.queue.length > 0 ? false : true;\r\n    }\r\n}\r\n\r\nexport default PriorityQueue;","import {PriorityQueue} from './PriorityQueue'\r\nimport {compareNodes} from './Utility'\r\n\r\nexport function Dijkstra(Adj, start, goal)\r\n{\r\n    if(!start)\r\n        console.log(\"start was not defined\")\r\n    if(!goal)\r\n        console.log(\"end was not defined\")\r\n    \r\n    var prioQ = new PriorityQueue();\r\n    var shortestPath = [] //Shortest path to goal node\r\n    var toBeVisited = {} //Closed set\r\n    var dist = []\r\n    var parent = []\r\n\r\n    for(var node in Adj)\r\n    {\r\n        dist[node] = Infinity\r\n        parent[node] = undefined\r\n    }\r\n\r\n    dist[start] = 0;\r\n    \r\n    for(var node in Adj)\r\n    {\r\n        prioQ.queue_item(node, dist[node])\r\n    }\r\n\r\n    while(!prioQ.isEmpty())\r\n    {\r\n        let qElem = prioQ.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [toBeVisited, shortestPath]\r\n        }\r\n        \r\n        //Iterate the neighbours and calculate their weights\r\n        for(var neighbour in Adj[minNode])\r\n        {\r\n            if(dist[neighbour] > dist[minNode] + Adj[minNode][neighbour])\r\n            {\r\n                dist[neighbour] = dist[minNode] + Adj[minNode][neighbour]\r\n                parent[neighbour] = minNode\r\n                //Update the priority of the node in priority queue\r\n                if(!toBeVisited[neighbour])\r\n                {\r\n                    prioQ.queue_item(neighbour, dist[neighbour])\r\n                    toBeVisited[neighbour] = dist[neighbour]\r\n                }\r\n            }\r\n        }\r\n            \r\n    }\r\n    \r\n    return toBeVisited, shortestPath\r\n}","import { isValidElement } from 'react';\r\nimport {PriorityQueue} from './PriorityQueue'\r\nimport {compareNodes, getIndex} from './Utility'\r\n\r\nfunction calcHeurestic(start, goal)\r\n{\r\n    var [x1,y1] = getIndex(start)\r\n    var [x2,y2] = getIndex(goal)\r\n    var dx = Math.abs(x1-x2)\r\n    var dy = Math.abs(y1-y2)\r\n    return (10 * (dx + dy) + (14 - 2 * 10) * Math.min(dx, dy))\r\n}\r\n\r\nexport function Astar(Adj, start, goal)\r\n{\r\n    var openSet = new PriorityQueue();\r\n    var gScore = {}        //g score value for every node in graph\r\n    var parent = {}        //Predecessor of any given node in graph\r\n    var visitedNodes = []  //Closed set\r\n    var nodesInOrder = []  //For visualizer\r\n    var shortestPath = []  //The shortest path\r\n\r\n    //Initialize start node\r\n    openSet.queue_item(start, 0);\r\n    visitedNodes.push(start)\r\n    gScore[start] = 0;\r\n    parent[start] = undefined\r\n\r\n\r\n    while(!openSet.isEmpty())\r\n    {\r\n        let qElem = openSet.dequeue();\r\n        let minNode = qElem.gridIndex\r\n        nodesInOrder[qElem.gridIndex] = gScore[qElem.gridIndex]\r\n        //Check if the minNode was goal\r\n        if(compareNodes(minNode, goal))\r\n        {\r\n            console.log(\"Goal reached\")\r\n            //Backtrack and return the shortest path\r\n            while(minNode != undefined && !compareNodes(minNode, start))\r\n            {\r\n                shortestPath.push(minNode)\r\n                minNode = parent[minNode]\r\n            }\r\n            shortestPath.push(start)\r\n            return [nodesInOrder, shortestPath]\r\n        }\r\n        \r\n        for(let neighbour in Adj[minNode])\r\n        {   \r\n            let next = getIndex(neighbour)\r\n            if(visitedNodes.includes(neighbour))\r\n                continue;\r\n            let newCost = gScore[minNode] + Adj[minNode][next]\r\n            if(!gScore[next] || newCost < gScore[next])\r\n            {                \r\n                parent[next] = minNode\r\n                //Calc the new fScore for the neighbour\r\n                gScore[next] = newCost\r\n                //Calculate f(n) (priority) for this new node\r\n                let weight = newCost + calcHeurestic(next, goal)\r\n                openSet.queue_item(next, weight)\r\n            }\r\n        }\r\n        visitedNodes.push(minNode.toString())\r\n    }\r\n\r\n    return;\r\n}","\r\nexport function BFS(graph, start, end)\r\n{\r\n    return\r\n}","import {getIndex} from './Utility'\r\n\r\nexport class Maze\r\n{\r\n    constructor(AdjList)\r\n    {\r\n        this.adj = AdjList\r\n        this.visitedNodes = []\r\n        this.init();\r\n    }\r\n\r\n    init()\r\n    {\r\n        //Initialize visited nodes 2d matrix\r\n        let nodes = Object.keys(this.adj)\r\n        var [maxRow,maxCol] = getIndex(nodes[nodes.length-1])\r\n        for(let i = 0; i <= maxCol; i++)\r\n        {\r\n            let tmpRow = []\r\n            for(let j = 0; j <= maxRow; j++)\r\n            {\r\n                tmpRow.push(false)\r\n            }\r\n            this.visitedNodes.push(tmpRow)\r\n        }\r\n        //Pick a node from the visited nodes, preferably from the top\r\n        this.generateMaze(nodes[0]);\r\n    }\r\n\r\n    generateMaze(nodeStr)\r\n    {\r\n        let node = getIndex(nodeStr);\r\n        //Mark the chosen node as visited\r\n        console.log(node)\r\n        this.visitedNodes[node[1]][node[0]] = true;\r\n        //Get the node's neighbours\r\n        let wallList = Object.keys(this.adj[nodeStr])\r\n        //Remove already visited neighbours, iterate in reverse since the indexes change when element is removed\r\n        for(let i = wallList.length-1; i >= 0; i--)\r\n        {\r\n            let nodeIdx = getIndex(wallList[i])\r\n            if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n            //Delete diagonial neighbours for the sake of cleaner maze\r\n            if(node[0] != nodeIdx[0] && node[1] != nodeIdx[1])\r\n            {\r\n                wallList.splice(i, 1);\r\n            }\r\n        }\r\n        //Now the neighbours list only contains 'obstacle' nodes, that are neighbours with the chosen cell in x or y axis\r\n        //Iterate through the list\r\n        while(wallList.length > 0)\r\n        {\r\n            //Pick a random neighbour from the list\r\n            let wall = wallList[Math.floor(Math.random() * Math.floor(wallList.length))] \r\n            wall = getIndex(wall)\r\n            let visitedCounter = 0;\r\n            //Check if the chosen nodes doesn't have 2 explored neighbour nodes\r\n            let wallNeighbours = Object.keys(this.adj[wall.toString()])\r\n            for(let i = wallNeighbours.length-1; i >= 0; i--)\r\n            {\r\n                let nodeIdx = getIndex(wallNeighbours[i])\r\n                if(this.visitedNodes[nodeIdx[1]][nodeIdx[0]])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                    visitedCounter += 1;\r\n                }\r\n                //Delete diagonial neighbours for the sake of cleaner maze\r\n                if(wall[0] != nodeIdx[0] && wall[1] != nodeIdx[1])\r\n                {\r\n                    wallNeighbours.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            //Now wallNeighbours only contains the neighbours that are obstacles, aka walls \r\n            //Check for count of visited neighbours\r\n            if(visitedCounter <= 2)\r\n            {\r\n                this.visitedNodes[wall[1]][wall[0]] = true\r\n                for(let i = 0; i < wallNeighbours.length; i++)\r\n                {\r\n                    wallList.push(wallNeighbours[i])\r\n                }\r\n            }\r\n            wallList.splice(wallList.indexOf(wall.toString()), 1);\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport GridItem from './GridItem'\r\nimport {Graph} from '../PathfindingAlgorithms/Graph'\r\nimport {Dijkstra} from '../PathfindingAlgorithms/Dijkstra'\r\nimport {Astar} from '../PathfindingAlgorithms/Astar'\r\nimport {BFS} from '../PathfindingAlgorithms/BFS'\r\nimport {Maze} from '../PathfindingAlgorithms/Maze'\r\nimport Node from '../PathfindingAlgorithms/Node'\r\nimport {compareNodes, getIndex, sleep} from '../PathfindingAlgorithms/Utility'\r\nimport './Grid.scss';\r\n\r\n\r\n//Current react layout is bad, we should've stored all this functionality in to a single component instead of two, Grid.jsx and PathfindingLayout.jsx\r\n//Now we need hacky methods to access child components states and call their functionality from parent component\r\nclass PathfindingLayout extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            gridRowCount: 35,                   \r\n            gridColCount: 72,\r\n\r\n            algorithm: undefined,\r\n            drawMode: undefined,\r\n            gridState: [],                   //Grid representation of node objects as 2d array\r\n            Graph: undefined,               //Graph representation of the grid (Adjacency list of the nodes and movement cost matrix)   \r\n\r\n            gridStartPos: undefined,\r\n            gridEndPos: undefined,\r\n            curGrid: undefined,             //Key of the current grid, for resetting the grid\r\n\r\n            isVisualized: false,\r\n            isAnimating: false,\r\n            animationSpeed: 50,                 //Animation speed in ms\r\n\r\n            showWeights: false,\r\n        }\r\n        this.handleAlgorithmModeChange = this.handleAlgorithmModeChange.bind(this);\r\n        this.handleDrawModeChange = this.handleDrawModeChange.bind(this);\r\n        this.handleResetClick = this.handleResetClick.bind(this);\r\n        this.handleSimulateClick = this.handleSimulateClick.bind(this);\r\n        this.generateMaze = this.generateMaze.bind(this);\r\n        this.animate = this.animate.bind(this);\r\n        this.AlgorithmTypes = Object.freeze({\r\n            Dijkstra: {Dijkstra},\r\n            Astar: {Astar},\r\n            BFS: {BFS},\r\n        })\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.setState({algorithm: this.AlgorithmTypes.Dijkstra, drawMode: 1});\r\n        this.initGrid();\r\n    }\r\n\r\n    //Resets the whole grid\r\n    //TODO:: Instead of iterating through the whole grid, we could just store the nodes that need to be cleared into a state as an array, would increase performance by a quite a bit.\r\n    async handleResetClick(){\r\n        //Creating a new key for our grid component recreates the component from scratch. Since we only have one component using math.random should be fine\r\n        let newId = Math.random()\r\n        //this.cancelAnimation();\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        var oldGrid = [...this.state.gridState]\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                var oldNode = oldGrid[i][j][1]\r\n                oldNode.nodeType = 0;\r\n                oldNode.weight = 0;\r\n                var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                oldGrid[i][j][0] = oldGridItem\r\n            }\r\n        }\r\n        var newGraph = new Graph(this.state.gridState)\r\n        this.setState({curGrid: newId, gridState: oldGrid, Graph: newGraph, gridStartPos: undefined, gridEndPos: undefined})\r\n    }\r\n\r\n    handleSpeedSlider = (e) =>\r\n    {\r\n        this.setState({animationSpeed: e.target.value})\r\n    }\r\n\r\n    handleCheckboxChange = (e) => \r\n    {\r\n        this.setState({showWeights: e.target.value})\r\n    }\r\n\r\n    cancelAnimation()\r\n    {\r\n        this.setState({isAnimating: false, isVisualized: false})\r\n        let oldGrid = [...this.state.gridState]\r\n        let oldGraph = this.state.Graph\r\n        //This is atleast o(n^2) and is very costly way of cancelling the animation, maybe store the animated nodes to a heap instead of iterating through whole matrix\r\n        for(var i = 0; i < oldGrid.length; i++)\r\n        {\r\n            for(var j = 0; j < oldGrid[i].length; j++)\r\n            {\r\n                if(oldGrid[i][j][0].props.visited)\r\n                {\r\n                    var oldNode = oldGrid[i][j][1]\r\n                    oldNode.nodeType = 0;\r\n                    var oldGridItem = React.cloneElement(oldGrid[i][j][0], {visited: false, styleName: 'grid-item', itemNode: oldNode})\r\n                    oldGrid[i][j][0] = oldGridItem\r\n                    oldGraph.updateNode(oldNode)\r\n                }\r\n            }\r\n        }\r\n        this.setState({gridState: oldGrid, Graph: oldGraph})\r\n        console.log(\"animation cancelled!\")\r\n    }\r\n\r\n    async handleSimulateClick(){\r\n        //Check if the grid in in animated state\r\n        if(this.state.isVisualized || this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n            await sleep(1);\r\n        }\r\n\r\n        if(this.state.gridState && this.state.gridStartPos && this.state.gridEndPos)\r\n        {\r\n            const start = this.state.gridStartPos.state.node.gridIndex\r\n            const goal = this.state.gridEndPos.state.node.gridIndex\r\n            //Call selected algorithm\r\n            //Create instance of the selected algorithm object\r\n            switch(this.state.algorithm)\r\n            {\r\n                case this.AlgorithmTypes.Dijkstra:\r\n                    var dijkstra = Dijkstra(this.state.Graph.adjacencyList, start, goal);\r\n                    this.animate(dijkstra[0], dijkstra[1])\r\n                    break;\r\n                case this.AlgorithmTypes.Astar:\r\n                    var astar = Astar(this.state.Graph.adjacencyList, start, goal)\r\n                    this.animate(astar[0], astar[1])\r\n                    break;\r\n                case this.AlgorithmTypes.BFS:\r\n                    var bfs = BFS(this.state.Graph.adjacencyList)\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            console.log(\"Grid was undefined\")\r\n        }\r\n    }\r\n\r\n    //Takes nodes to animate in array that's ordered\r\n    //nodesInOrder[0] is the node index and [1] is the weight of the node\r\n    async animate(nodesInOrder, shortestPath)\r\n    {\r\n        console.log(\"Animation started\");\r\n\r\n        await this.setState({isAnimating: true})\r\n\r\n        //Animate visitedNodes\r\n        let oldGrid = [...this.state.gridState];\r\n        for(const [nodeIdx, weight] of Object.entries(nodesInOrder))\r\n        {\r\n            await sleep(100 - this.state.animationSpeed);\r\n            if(!this.state.isAnimating)\r\n                return\r\n\r\n            //Get the index of the node, nodesInOrder is an array of strings instead of numbers (Because we're using js and not ts...)\r\n            var [x,y] = getIndex(nodeIdx)\r\n\r\n            //No need to animate the goal node\r\n            if(compareNodes([x,y], this.state.gridEndPos.state.node.gridIndex) || compareNodes([x,y], this.state.gridStartPos.state.node.gridIndex))\r\n                continue\r\n            var gridItem = oldGrid[y][x][0]\r\n\r\n            //Create inline style object depending on the weight value \r\n            let c = [0,191,255]     //rgb\r\n            c[0] += weight/3;\r\n            c[1] -= weight/3*2;\r\n            c[2] -= weight/3*2;\r\n\r\n            const _styleObj = {\r\n                'background-color': 'rgb('+c[0]+','+c[1]+','+c[2]+')'\r\n            };\r\n\r\n            //Clone/Duplicate the gridItem component with new properties and overwrite the old one\r\n            let newGridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-visited', styleObj: _styleObj, weight: weight, showWeight: this.state.showWeights});\r\n            oldGrid[y][x][0] = newGridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        \r\n        //Animate shortest path in the end, no need to animate start or goal\r\n        for(let i = 1; i < shortestPath.length-1; i++)\r\n        {\r\n            await sleep(100 - this.state.animationSpeed)\r\n            if(!this.state.isAnimating)\r\n                return\r\n            let [x,y] = getIndex(shortestPath[i])\r\n            let gridItem = oldGrid[y][x][0]\r\n\r\n            gridItem = React.cloneElement(gridItem, {visited: true, styleName: 'grid-item-shortestPath', styleObj: undefined});\r\n            oldGrid[y][x][0] = gridItem\r\n            this.setState({gridState: oldGrid})\r\n        }\r\n        this.setState({gridState: oldGrid, isVisualized: true, isAnimated: false})\r\n\r\n\r\n    }\r\n\r\n    //Recursive maze generation\r\n    async generateMaze()\r\n    {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isAnimating || this.state.isVisualized)\r\n        {\r\n            //Since we don't need to clear the \"Visited nodes\" here, we can simply just reset the whole grid\r\n            this.handleResetClick();\r\n            await sleep(10);\r\n        }\r\n        //Generate maze from the current grid state\r\n        var maze = new Maze(this.state.Graph.adjacencyList);\r\n        await this.setState({isAnimating: true})\r\n        for(var x = 0; x < maze.visitedNodes.length; x++)\r\n        {\r\n            for(var y = 0; y < maze.visitedNodes[x].length; y++)\r\n            {\r\n                if(!this.state.isAnimating)\r\n                    return\r\n                //If node is false, it's an obstacle\r\n                if(maze.visitedNodes[x][y] == false)\r\n                {\r\n                    let newGrid = this.state.gridState\r\n                    //Update the gridItem and the node in gridState\r\n                    await this.updateGridItem([y,x], newGrid[x][y][1], 3);\r\n                    //Sleep for a bit before next iteration\r\n                    await sleep(100 - this.state.animationSpeed);\r\n                }\r\n            }\r\n        }\r\n        this.setState({isAnimating: false, isVisualized: true})\r\n    }\r\n\r\n    handleAlgorithmModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"Dijkstra\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n            case \"Astar\":\r\n                this.setState({algorithm: this.AlgorithmTypes.Astar})\r\n                break;\r\n            case \"BFS\":\r\n                this.setState({algorithm: this.AlgorithmTypes.BFS})\r\n                break;\r\n            default:\r\n                this.setState({algorithm: this.AlgorithmTypes.Dijkstra})\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleDrawModeChange(e)\r\n    {\r\n        switch(e.target.value)\r\n        {\r\n            case \"start\":\r\n                this.setState({drawMode: 1})\r\n                break;\r\n            case \"end\":\r\n                this.setState({drawMode: 2})\r\n                break;\r\n            case \"obstacle\":\r\n                this.setState({drawMode: 3})\r\n                break;\r\n            default:\r\n                this.setState({drawMode: 1})\r\n                break;\r\n        }\r\n        //TODO:: Handle diff types as enums\r\n        console.log(\"this changed to \" + e.target.value);\r\n    }\r\n\r\n    gridWasClicked = (gridItem) => {\r\n        //Check if the grid in in animated state\r\n        if(this.state.isVisualized || this.state.isAnimating)\r\n        {\r\n            this.cancelAnimation();\r\n        }\r\n        //Check if the clicked node was already the selected type\r\n        if(gridItem.state.node.nodeType === this.state.drawMode)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        let newNode = gridItem.state.node;\r\n        switch(this.state.drawMode)\r\n        {\r\n            //Draw mode is start\r\n            case 1:\r\n                if(this.state.gridStartPos)\r\n                {\r\n                    //Create temporary copy of the current start position node (Found by index from gridState array), so we don't mutate the active node directly\r\n                    let oldX = this.state.gridStartPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridStartPos.state.node.gridIndex[1]\r\n                    let oldStartNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldStartNode.nodeType = 0;\r\n                    \r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldStartNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new starting point\r\n                newNode.nodeType = 1\r\n                this.updateGridItem(newNode.gridIndex, newNode, 1);\r\n                //Update the grid starting position\r\n                this.setState({gridStartPos: gridItem})\r\n                break;\r\n            //Draw mode is end\r\n            case 2:\r\n                if(this.state.gridEndPos)\r\n                {\r\n                    //Create temporary copy of the current node\r\n                    let oldX = this.state.gridEndPos.state.node.gridIndex[0]\r\n                    let oldY = this.state.gridEndPos.state.node.gridIndex[1]\r\n                    let oldEndNode = this.state.gridState[oldY][oldX][1];\r\n                    //Change the node type to 0\r\n                    oldEndNode.nodeType = 0;\r\n                    //Update the old starting node's information in the grid state array\r\n                    this.updateGridItem([oldX, oldY], oldEndNode, 0);\r\n\r\n                }\r\n                //Change the new clicked item to be the new ending point\r\n                newNode.nodeType = 2\r\n                this.updateGridItem(newNode.gridIndex, newNode, 2);\r\n                //Update the grid starting position\r\n                this.setState({gridEndPos: gridItem})\r\n                break;\r\n            //Draw mode is obstacle\r\n            case 3:\r\n                newNode.nodeType = this.state.drawMode;\r\n                this.updateGridItem(newNode.gridIndex, newNode, 3);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    updateGridItem(idx, node, nodeType)\r\n    {\r\n        let oldGridState = [...this.state.gridState]\r\n        let _styleName = \"\" \r\n        switch(nodeType)\r\n        {\r\n            case 1:\r\n                _styleName = 'grid-item-start';\r\n                break;\r\n            case 2:\r\n                _styleName = 'grid-item-end';\r\n                break;\r\n            case 3:\r\n                _styleName = 'grid-item-obstacle';\r\n                break;\r\n            default:\r\n                _styleName = 'grid-item'\r\n                break;\r\n        }\r\n\r\n        let oldGridItem = React.cloneElement(oldGridState[idx[1]][idx[0]][0], {itemNode: node, styleName: _styleName});\r\n        oldGridState[idx[1]][idx[0]][0] = oldGridItem\r\n        node.nodeType = nodeType;       //For some reason the node's type isn't always the same as the parameter\r\n        oldGridState[idx[1]][idx[0]][1] = node\r\n\r\n        //Update the node in adjacency list aswell\r\n        let tmpGraph = this.state.Graph\r\n        tmpGraph.updateNode(node)\r\n        this.setState({gridState: oldGridState, Graph: tmpGraph})\r\n    }\r\n\r\n    pushElemsToGrid(elem){\r\n        let tmpArr = this.state.gridState;\r\n        tmpArr.push(elem);\r\n        this.setState({gridState: tmpArr});\r\n    }\r\n\r\n    initGrid()\r\n    {\r\n        //By calculating window.innerWidth/Heigth we could divide it by width/heigth of a GridItem and get the count to fill out the container\r\n        let counter = 0;\r\n        for(let row = 0; row < this.state.gridRowCount; row++)\r\n        {\r\n            let tmpRow = [];\r\n            for(let col = 0; col < this.state.gridColCount; col++)\r\n            {\r\n                //Create node object array which represents the grid's state (Used for data processing) and GridItem array which is used to render the grid\r\n                let node = new Node(col, row, 0);\r\n                var bool = false;\r\n                tmpRow.push([<GridItem key={counter} gridWasClicked={this.gridWasClicked} itemNode={node} styleName='grid-item' visited={bool}/>, node]);\r\n                \r\n                counter++;\r\n            }\r\n            this.pushElemsToGrid(tmpRow);\r\n        }\r\n        this.setState({Graph: new Graph(this.state.gridState)})\r\n    }\r\n\r\n    render(){\r\n        const grid = this.state.gridState ? this.state.gridState : [[1]]\r\n        return(\r\n            <div className=\"layout-container\">\r\n                <nav className=\"layout-nav-bar\">\r\n                    <button className=\"layout-nav-button\" onClick={this.handleSimulateClick}>\r\n                        Simulate\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.generateMaze}>\r\n                        Generate maze\r\n                    </button>\r\n                    <button className=\"layout-nav-button\" onClick={this.handleResetClick}>\r\n                        Reset\r\n                    </button>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Algorithm mode</label>\r\n                        <select name=\"algorithmMode\" id=\"algorithm_mode\" className=\"selector-dropdown\" onChange={this.handleAlgorithmModeChange}>\r\n                            <option value=\"Dijkstra\">Dijkstra</option>\r\n                            <option value=\"Astar\">A*</option>\r\n                            <option value=\"BFS\">Breadth-first-search</option>\r\n                        </select>\r\n                    </div>\r\n                    {/* Checkbox container for displaying weights, not ready for use yet */}\r\n                    {/* <div className=\"checkbox-container\">\r\n                        <label className=\"slider-description\">Show weights: </label>\r\n                        <input type=\"checkbox\" onChange={this.handleCheckboxChange}/>\r\n                    </div> */}\r\n                    <div className=\"slider-container\">\r\n                        <label className=\"slider-description\">Animation speed: {this.state.animationSpeed}</label>\r\n                        <input onChange={this.handleSpeedSlider} type=\"range\" className=\"animation-speed-slider\" min=\"1\" max=\"100\" value={this.state.animationSpeed}/>\r\n                    </div>\r\n                    <div className=\"dropdown-container\">\r\n                        <label className=\"dropdown-description\">Drawing mode</label>\r\n                        <select name=\"drawingMode\" id=\"drawing_mode\" className=\"selector-dropdown\" onChange={this.handleDrawModeChange}>\r\n                            <option value=\"start\">Start location</option>\r\n                            <option value=\"end\">End location</option>\r\n                            <option value=\"obstacle\">Obstacle</option>\r\n                        </select>\r\n                    </div>\r\n                </nav>\r\n            <div>\r\n                <div key={this.state.curGrid} className=\"grid-container\">\r\n                    {grid.map((row, id) => <div key={id} className=\"grid-row\">{(row.map((item, id) => item[0]))}</div>)}\r\n                </div>\r\n            </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingLayout;","import React from 'react';\r\nimport PathfindingLayout from \"./PathfindingLayout\";\r\nimport './Layout.scss';\r\n\r\nclass Layout extends React.Component\r\n{\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            currentLayout: <PathfindingLayout/>,\r\n        };\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div className=\"layout-wrapper\">\r\n                {this.state.currentLayout}\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default Layout;","import './App.css';\nimport Layout from './Components/Layout'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Layout/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}